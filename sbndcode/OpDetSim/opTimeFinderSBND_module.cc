////////////////////////////////////////////////////////////////////////
// Class:       opTimeFinderSBND
// Module Type: analyzer
// File:        opTimeFinderSBND_module.cc
//
// Generated at Thu Mar  1 13:49:31 2018 by Laura Paulucci Marinho using artmod
// from cetpkgsupport v1_13_00.
////////////////////////////////////////////////////////////////////////


#include "larcore/Geometry/Geometry.h"
#include "lardataobj/RawData/OpDetWaveform.h"
//#include "larana/OpticalDetector/OpHitFinder/PMTPulseRecoBase.h"
//#include "larana/OpticalDetector/OpHitFinder/AlgoThreshold.h"
//#include "larana/OpticalDetector/OpHitFinder/AlgoSiPM.h"
//#include "larana/OpticalDetector/OpHitFinder/AlgoSlidingWindow.h"
//#include "larana/OpticalDetector/OpHitFinder/AlgoFixedWindow.h"
//#include "larana/OpticalDetector/OpHitFinder/AlgoCFD.h"
//#include "larana/OpticalDetector/OpHitFinder/PedAlgoEdges.h"
//#include "larana/OpticalDetector/OpHitFinder/PedAlgoRollingMean.h"
//#include "larana/OpticalDetector/OpHitFinder/PedAlgoUB.h"
//#include "larana/OpticalDetector/OpHitFinder/PulseRecoManager.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
//#include "larana/OpticalDetector/OpHitFinder/OpHitAlg.h"
//#include "lardataobj/Simulation/BeamGateInfo.h"


#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art_root_io/TFileService.h"

#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardata/DetectorInfoServices/DetectorClocksServiceStandard.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/Simulation/sim.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/SimPhotons.h"
#include "sbndcode/Utilities/SignalShapingServiceSBND.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"

#include "TMath.h"
#include "TH1D.h"
#include "TRandom3.h"
#include "TF1.h"
#include <map>
#include <vector>
#include <algorithm>

namespace opdet{

  class opTimeFinderSBND;

  class opTimeFinderSBND : public art::EDAnalyzer {
  public:
    explicit opTimeFinderSBND(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
    opTimeFinderSBND(opTimeFinderSBND const &) = delete;
    opTimeFinderSBND(opTimeFinderSBND &&) = delete;
    opTimeFinderSBND & operator = (opTimeFinderSBND const &) = delete;
    opTimeFinderSBND & operator = (opTimeFinderSBND &&) = delete;

  // Required functions.
    void analyze(art::Event const & e) override;
    typedef std::pair<double, double> pair;
    static bool mysort(pair l, pair r);


  private:

  // Declare member data here.
    std::string fInputModuleName;
    double fSampling; //in GHz
    double fTransitTime; //ns
    double fRiseTime; //in ns
    double fMeanAmplitude; //in ADC
    double fReadoutWindow; //in ns
    double fPreTrigger; //in ns
    double fSaturation; //in number of p.e.
    int fThreshold; //in ADC
    int fEvNumber;
    int fChNumber;
    int fSize;
    int fTimePMT;         //Start time of PMT signal
    int fTimeMax;         //Time of maximum (minimum) PMT signal
    int fRecoTime;         //Diff for reconstructed time of PMT signal
    TH1D* wvfHist;          //processed waveform histogram 
    void subtractBaseline(TH1D* hist);
    bool findPeak(TH1D* h, size_t& time);
    double int_total;
    std::stringstream histname;
  };


  opTimeFinderSBND::opTimeFinderSBND(fhicl::ParameterSet const & p)
    :
    EDAnalyzer(p)  // ,
 // More initializers here.
  {

    fInputModuleName = p.get< std::string >("InputModule" );
    fTransitTime     = p.get< double >("TransitTime"  ); //ns
    fRiseTime        = p.get< double >("RiseTime"     ); //in ns
    fMeanAmplitude   = p.get< double >("MeanAmplitude"); //in ADC
    fReadoutWindow   = p.get< double >("ReadoutWindow"); //in ns
    fPreTrigger      = p.get< double >("PreTrigger"   ); //in ns
    fSaturation      = p.get< double >("Saturation"   ); //in number of p.e.
    fSampling        = p.get< double >("Sampling"     ); //in GHz
    fThreshold       = p.get< double >("Threshold"    ); //in ADC
  }

  void opTimeFinderSBND::analyze(art::Event const & e)
  {
  // Implementation of required member function here.
    fEvNumber = e.id().event();
    std::cout << "Event #" << fEvNumber << std::endl;

    art::ServiceHandle<art::TFileService> tfs;
    histname.str(std::string());
    histname << "event_" << fEvNumber;
    TH1D* htime = tfs->make< TH1D >(histname.str().c_str(), "", 200,-100.0,100.0);
    art::Handle< std::vector< raw::OpDetWaveform > > wvfHandle;
    e.getByLabel(fInputModuleName, wvfHandle);

    if(!wvfHandle.isValid()){
  	std::cout <<Form("Did not find any waveform") << std::endl;
    }

    std::cout << "Number of photon channels: " << wvfHandle->size() << std::endl;

    size_t time;
    size_t tmin = 1e9;
    std::map<double, double> timeMap; //order: recoTime, charge
//    std::map<int, double> chargeMap;

    for(auto const& wvf : (*wvfHandle)){
	fChNumber = wvf.ChannelNumber();
//	std::cout << "Photon channel: " << fChNumber << std::endl;
	histname.str(std::string());
        histname << "event_" << fEvNumber <<"_opchannel_" << fChNumber;
	wvfHist = new TH1D(histname.str().c_str(), "Histogram", wvf.size(),0, double(wvf.size()));
	for(unsigned int i=0;i<wvf.size();i++){
	  wvfHist->SetBinContent(i,wvf[i]);
	}
	//Findind the signal starting time for each channel
	subtractBaseline(wvfHist);
        int_total= wvfHist->Integral(0, wvf.size());
	tmin = 1e9;
        while(findPeak(wvfHist,time)){
          time = time/fSampling;
  //        std::cout << " Find peak time: " << time << std::endl;
          if(time<tmin)tmin=time;
        }
	fRecoTime = tmin - (fPreTrigger - wvf.TimeStamp());
        timeMap[fRecoTime]=int_total; 
//        htime->Fill(fRecoTime);
//	std::cout << "TimeStamp " << wvf.TimeStamp() << " Rec time: " << tmin << " Diff " << fRecoTime << " wvf size: "<< wvf.size() <<std::endl;
//	std::cout << wvf.ChannelNumber() << " " << int_total <<std::endl;
	delete wvfHist;
    }
    std::vector<pair> vec; //empty vector of pairs
    std::copy(timeMap.begin(),timeMap.end(),std::back_inserter<std::vector<pair>>(vec)); //copy key-value pair from the map to the vec
    //sort the vec by increasing order of its pair's second value if second value are equal, order by the pair's first value
    /*std::sort(vec.begin(),vec.end(),[](const pair& l, const pair& r){
      if(l.second != r.second) return l.second < r.second;
      return l.first < r.first;
    });*/
    std::sort(vec.begin(),vec.end(),mysort);
    unsigned int j=1;
    for(auto const &pair: vec){
     if(j<=20) htime->Fill(pair.first);
     j++;
    }
  }

  DEFINE_ART_MODULE(opTimeFinderSBND)


  void opTimeFinderSBND::subtractBaseline(TH1D* h){
    double baseline = 0.0;
    int width = 100;
  
    for(int i=1; i<=width; i++){
	baseline+=h->GetBinContent(i);
    }
    baseline=baseline/width;

    for(int i=1; i<h->GetNbinsX(); i++)h->SetBinContent(i, baseline-(h->GetBinContent(i)));

  }

  bool opTimeFinderSBND::findPeak(TH1D* h, size_t& time){

    //Gets info from highest peak and suppress it in histogram
    double aux = h->GetMaximum();
    double max = aux;
    size_t bin = h->GetMaximumBin();
    size_t bmax = bin;

    //std::cout << "aux: " << aux << " Threshold: " << fThreshold << std::endl;


 //   time = bin; //for peak time

    if(aux<fThreshold)return false;

//    while(aux>fThreshold/2){
    while(aux>fThreshold/2){
        h->SetBinContent(bin,0.0);
        bin--;
        aux = h->GetBinContent(bin);
    }

    time = bin; //for rise time

    aux = max;
    bin = bmax;
   
   while(aux>fThreshold){
        h->SetBinContent(bin,0.0);
        bin++;
        aux = h->GetBinContent(bin);
    }

    return true;		

  }

  bool opTimeFinderSBND::mysort(pair l, pair r){
      if(l.second != r.second){ 
        return l.second < r.second;
      }else{
        return l.first < r.first;
      }
  }

}

