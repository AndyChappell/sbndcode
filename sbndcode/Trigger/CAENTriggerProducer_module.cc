/*
 File:    
 Purpose: 
 Author:  
 Date:    
 Version: 1.0
*/

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art_root_io/TFileService.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Utilities/Exception.h"

// LArSoft includes
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/WireGeo.h"
#include "lardataobj/RecoBase/Hit.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardataobj/Simulation/AuxDetSimChannel.h"
#include "larcore/Geometry/AuxDetGeometry.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/raw.h"

#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardata/DetectorInfoServices/DetectorClocksServiceStandard.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardataobj/Simulation/sim.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/SimPhotons.h"

// SBN/SBND includes
#include "sbndcode/Utilities/SignalShapingServiceSBND.h"
#include "sbndcode/OpDetSim/sbndPDMapAlg.hh"
#include "sbnobj/SBND/Trigger/pmtTrigger.hh"

// ROOT includes
#include "TH1D.h"
#include "TFile.h"
#include "TTree.h"

// C++ includes
#include <algorithm>
#include <vector>
#include <cmath>
#include <memory>
#include <string>

class CAENTriggerProducer: public art::EDProducer {
public:
   // The destructor generated by the compiler is fine for classes
   // without bare pointers or other resource use.
   // Plugins should not be copied or assigned.
   explicit CAENTriggerProducer(fhicl::ParameterSet const & p);
   CAENTriggerProducer(CAENTriggerProducer const &) = delete;
   CAENTriggerProducer(CAENTriggerProducer &&) = delete;
   CAENTriggerProducer & operator = (CAENTriggerProducer const &) = delete;
   CAENTriggerProducer & operator = (CAENTriggerProducer &&) = delete;

   // Required functions.
   void produce(art::Event & evt) override;
   void reconfigure(fhicl::ParameterSet const & p);


private:
   // Define producer-specific functions
   void ResetPmtTriggerVars(int n);
   // Define global variables
   int run;
   int subrun;
   int event;

   std::stringstream histname; //raw waveform hist name
   std::stringstream histname2; //other hists name

   //pmt hardware trigger variables
   std::vector<int> pmtTrigger_npmtshigh;    ///< number of pmt pairs above threshold, index = time during trigger window (usually beam spill)
   std::vector<double> pmtTrigger_time;
   int pmtTrigger_maxpassed;    ///< maximum number of pmt pairs above threshold during trigger window (usually beam spill)
   
   size_t fChNumber; //channel number
   double Sampling; //sampling rate

   std::string opdetType; //opdet wavform's opdet type (required to be pmt_coated or pmt_uncoated)

   // std::vector<int> channel_numbers = {6,7,8,9,10,11,12,13,14,15,16,17,36,37,38,39,40,41,60,61,62,63,64,65,66,67,68,69,70,71,
   //   84,85,86,87,88,89,90,91,92,93,94,95,114,115,116,117,118,119,138,139,140,141,142,143,144,145,146,147,148,149,
   //   162,163,164,165,166,167,168,169,170,171,172,173,192,193,194,195,196,197,216,217,218,219,220,221,222,223,224,225,226,227,
   //   240,241,242,243,244,245,246,247,248,249,250,251,270,271,272,273,274,275,294,295,296,297,298,299,300,301,302,303,304,305};

   // List parameters for the fcl file
   std::string fInputModuleName; //opdet waveform module name (set in fcl)
   std::string fpmtTriggerModuleLabel; ///< Label for pmtTrigger dataproduct (to be set vis fcl)
   std::vector<std::string> fOpDetsType = {"pmt_coated", "pmt_uncoated"}; //types of optical detetcors (e.g. "pmt_coated", "xarapuca_vuv", etc.), should only be pmt_coated and pmt_uncoated (set in fcl)
   int fpmtMaxThreshold; // threshold for the max number of PMTs per event (low threshold)
   int fpmtThreshold; // threshold to pass the trigger 

   // std::vector<int> fPair1 = {6,8,10,12,14,16,36,38,40,84,86,88,90,92,94,114,116,118,138,140,142,144,146,148,162,164,166,168,170,172,192,194,196,216,218,220,222,224,226,240,242,244,246,248,250,270,272,274,294,296}; //channel numbers for first set of paired pmts (set in fcl)
   // std::vector<int> fPair2 = {7,9,11,13,15,17,37,39,41,85,87,89,91,93,95,115,117,119,139,141,143,145,147,149,163,165,167,169,171,173,193,195,197,217,219,221,223,225,227,241,243,245,247,249,251,271,273,275,295,297}; //channel numbers for second set of paired pmts (set in fcl)
   // std::vector<int> fUnpaired = {298,299,300,301,302,303,304,305};//channel numbers for unpired pmts (set in fcl)
   
   double fWindowStart; //start time (in us) of trigger window (set in fcl, 0 for beam spill)
   double fWindowEnd; //end time (in us) of trigger window (set in fcl, 1.6 for beam spill)

   // services
   opdet::sbndPDMapAlg pdMap; //map for photon detector types
   art::ServiceHandle<art::TFileService> tfs;

}; // class CAENTriggerProducer

CAENTriggerProducer::CAENTriggerProducer(fhicl::ParameterSet const & p)
   : EDProducer(p)
{
   produces<std::vector< raw::OpDetWaveform >>();

   auto const clockData = art::ServiceHandle<detinfo::DetectorClocksService const>()->DataForJob();
   Sampling = clockData.OpticalClock().Frequency(); // MHz
   this->reconfigure(p);
}

// Constructor
void CAENTriggerProducer::reconfigure(fhicl::ParameterSet const & p)
{
   // Initialize member data here
   fInputModuleName       = p.get< std::string >("InputModule", "opdaq");
   fpmtTriggerModuleLabel = p.get<std::string>("pmtTriggerModuleLabel", "pmttriggerproducer");
   fOpDetsType            = p.get<std::vector<std::string> >("OpDetsType");
   fpmtMaxThreshold       = p.get<double>("fpmtMaxThreshold", 10);
   fpmtThreshold          = p.get<int>("fpmtThreshold", 40); 
   // fPair1                 = p.get<std::vector<int> >("Pair1");
   // fPair2                 = p.get<std::vector<int> >("Pair2");
   // fUnpaired              = p.get<std::vector<int> >("Unpaired");
   fWindowStart           = p.get<double>("WindowStart",0.0);
   fWindowEnd             = p.get<double>("WindowEnd",1.6);
}

void CAENTriggerProducer::produce(art::Event & e)
{
   std::unique_ptr< std::vector< raw::OpDetWaveform > > wvfVecPtr(std::make_unique< std::vector< raw::OpDetWaveform > > ());

   // load event info
   run = e.run();
   subrun = e.subRun();
   event = e.id().event();

   std::cout << "Processing event " << event << std::endl;

   // get waveforms 
   art::Handle< std::vector< raw::OpDetWaveform > > waveHandle;
   e.getByLabel(fInputModuleName, waveHandle);
   if(!waveHandle.isValid()) {
      std::cout << Form("Did not find any G4 photons from a producer: %s", "largeant") << std::endl;
   }
   std::vector< raw::OpDetWaveform > raw_wvf_vector;
   raw_wvf_vector.reserve(waveHandle->size());

   // get pmt trigger info 
   art::Handle<std::vector<sbnd::comm::pmtTrigger> > pmtTriggerListHandle;
   std::vector<art::Ptr<sbnd::comm::pmtTrigger> > pmttriggerlist;
   if (e.getByLabel(fpmtTriggerModuleLabel, pmtTriggerListHandle)){
      art::fill_ptr_vector(pmttriggerlist, pmtTriggerListHandle);
      ResetPmtTriggerVars( (int)pmttriggerlist[0]->numPassed.size());
      for (int i=0; i < (int)pmttriggerlist[0]->numPassed.size(); i++){
         pmtTrigger_npmtshigh[i] = pmttriggerlist[0]->numPassed[i];
      }
      pmtTrigger_maxpassed = pmttriggerlist[0]->maxPMTs;
   }
   for (double i = fWindowStart; i<fWindowEnd+(4./Sampling); i+=(4./Sampling)){
      pmtTrigger_time.push_back(i);
   }
   
   if (event!=1 && event<3){
      histname.str(std::string());
      histname << "event_" << event
               << "_npmt";
      //Create a new histogram for binary waveform
      TH1I *npmt_time = tfs->make< TH1I >(histname.str().c_str(), "Total # of PMTs during beam spill", pmtTrigger_npmtshigh.size(), fWindowStart, fWindowEnd+(4./Sampling));
      npmt_time->GetXaxis()->SetTitle("t (#mus)");
      for(unsigned int i = 0; i < pmtTrigger_npmtshigh.size(); i++) {
         npmt_time->SetBinContent(i + 1, pmtTrigger_npmtshigh[i]);
      }
      
   } // end histo 

   // get the time information for every entry into the waveform!
   // caen will see the waveform with 0.08 us, convert waveform into that sampling rate, and then look for the trigger time? 
   std::vector< raw::OpDetWaveform > wvf_vector; 

   // set the threshold for # of total PMTs
   if (pmtTrigger_maxpassed > fpmtMaxThreshold){ // passes the initial threshold
      double trig_time = -999; 
      for (size_t i=0; i< pmtTrigger_npmtshigh.size(); i++){
         if (pmtTrigger_npmtshigh[i] >= fpmtThreshold){
            trig_time = pmtTrigger_time[i];
            break;
         }
      }

      if (trig_time != -999){
         int wvf_channel = -1;
         std::vector< raw::ADC_Count_t> wvf_down;
         std::vector<double> wvf_down_time;

         for (auto const& wvf : *waveHandle){
            wvf_channel = wvf.ChannelNumber();
            opdetType = pdMap.pdType(wvf_channel);
            if (std::find(fOpDetsType.begin(), fOpDetsType.end(), opdetType) == fOpDetsType.end()) {continue;}
            
            double wvf_starttime = wvf.TimeStamp();
            // double wvf_endtime = double(wvf.size()) / Sampling + wvf_starttime; //in us
            
            // downsampled wvf 
            wvf_down.reserve(int(wvf.size()/4));
            for (size_t i=0; i < wvf.size(); i++){
               if (i%4==0){wvf_down.push_back(wvf[i]);}
            }

            // get a vector of timestamps for the downsampled wvf 
            // find the corresponding time index in the downsampeld wvf for the trigger time 
            int time_idx = -1; 
            double wvf_trig_time = -999.; 
            wvf_down_time.reserve(wvf_down.size());
            for (size_t i=0; i<wvf_down.size(); i++){
               double time = wvf_starttime + i/Sampling;
               wvf_down_time.push_back(time);
               if (abs(time-trig_time) <= 4/Sampling){ wvf_trig_time = time; time_idx = (wvf_down_time.size()-1);}
            }
            // check that the trigger time is found in the downsampled waveform 
            if (time_idx == -1){ std::cout << "time not found in the waveform!" << std::endl; break;}
            if (wvf_trig_time == -999){continue;}
            
            raw::OpDetWaveform new_wvf = raw::OpDetWaveform(wvf_trig_time, wvf_channel);
            double new_start_time = 1.;
            double new_end_time = 1.; 
            for (size_t i = 0; i < wvf_down.size(); i++){
            // want the trig time window to be 10 us :  ) 
               if ((trig_time-wvf_down_time[i]) <= 1 || (wvf_down_time[i] - trig_time) <= 9){
                  if (wvf_down_time[i] < new_start_time){ new_start_time = wvf_down_time[i];}
                  if (wvf_down_time[i] > new_end_time){ new_end_time = wvf_down_time[i];}
                  new_wvf.push_back(wvf_down[i]);
               }
            }

            if (event!=-1 && event<3){
               histname2.str(std::string());
               histname2 << "event_" << event
                  << "_opchannel_" << wvf_channel
                  << "_" << opdetType;
               
               TH1D *wvfHist = tfs->make< TH1D >(histname2.str().c_str(), "Triggered Downsampled Raw Waveform", new_wvf.size(), new_start_time, new_end_time);
               wvfHist->GetXaxis()->SetTitle("t (#mus)");
               for(unsigned int i = 0; i < new_wvf.size(); i++) {
                  wvfHist->SetBinContent(i + 1, (double)new_wvf[i]);
               }
            } // end histo 
            wvfVecPtr->push_back(new_wvf);
         } // end waveform loop
      } // end per event threshold 
   } // end threshold if 
   e.put(std::move(wvfVecPtr));
} // CAENTriggerProducer::produce()

void CAENTriggerProducer::ResetPmtTriggerVars(int n){
  pmtTrigger_npmtshigh.assign(n, -999);
  pmtTrigger_maxpassed = 0;
}

// A macro required for a JobControl module.
DEFINE_ART_MODULE(CAENTriggerProducer)
