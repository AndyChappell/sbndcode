/////////////////////////////////////////////////////////////////////////////
/// Class:       CRTT0Matching
/// Module Type: producer
/// File:        CRTT0Matching_module.cc
///
/// Author:         Thomas Brooks
/// E-mail address: tbrooks@fnal.gov
///
/// Modified from CRTT0Matching by Thomas Warburton.
/////////////////////////////////////////////////////////////////////////////

// sbndcode includes
#include "sbndcode/CRT/CRTProducts/CRTHit.hh"
#include "sbndcode/CRT/CRTUtils/CRTT0MatchAlg.h"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art_root_io/TFileService.h"
#include "art_root_io/TFileDirectory.h"

#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <iterator>
#include <algorithm>

// LArSoft
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/WireGeo.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "larsim/MCCheater/BackTrackerService.h"

// ROOT
#include "TVector3.h"


namespace sbnd {
  
  class CRTT0Matching : public art::EDProducer {
  public:

    explicit CRTT0Matching(fhicl::ParameterSet const & p);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTT0Matching(CRTT0Matching const &) = delete;
    CRTT0Matching(CRTT0Matching &&) = delete;
    CRTT0Matching & operator = (CRTT0Matching const &) = delete; 
    CRTT0Matching & operator = (CRTT0Matching &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;

    // Selected optional functions.
    void beginJob() override;

    void endJob() override;

    void reconfigure(fhicl::ParameterSet const & p);

  private:

    // Params got from fcl file.......
    art::InputTag fTpcTrackModuleLabel; ///< name of track producer
    art::InputTag fCrtHitModuleLabel;   ///< name of crt producer
    double        fDistanceLimit;       ///< Maximum distance between projected crossing point and CRT hit
    double        fMinTrackLength;      ///< Minimum track length to perform T0 matching on
    double        fTrackDirectionFrac;  ///< Minimum track length to perform T0 matching on

    CRTT0MatchAlg t0Alg;

  }; // class CRTT0Matching


  CRTT0Matching::CRTT0Matching(fhicl::ParameterSet const & p)
    : EDProducer(p), t0Alg()
  // Initialize member data here, if know don't want to reconfigure on the fly
  {

    // Call appropriate produces<>() functions here.
    produces< std::vector<anab::T0>               >();
    produces< art::Assns<recob::Track , anab::T0> >();
    
    reconfigure(p);

  } // CRTT0Matching()


  void CRTT0Matching::reconfigure(fhicl::ParameterSet const & p)
  {

    fTpcTrackModuleLabel = (p.get<art::InputTag> ("TpcTrackModuleLabel"));
    fCrtHitModuleLabel   = (p.get<art::InputTag> ("CrtHitModuleLabel")); 
    fDistanceLimit       = (p.get<double>        ("DistanceLimit")); 
    fMinTrackLength      = (p.get<double>        ("MinTrackLength")); 
    fTrackDirectionFrac  = (p.get<double>        ("TrackDirectionFrac")); 

  } // CRTT0Matching::reconfigure()


  void CRTT0Matching::beginJob()
  {

  } // CRTT0Matching::beginJob()

  void CRTT0Matching::produce(art::Event & event)
  {

    // Create anab::T0 objects and make association with recob::Track
    std::unique_ptr< std::vector<anab::T0> > T0col( new std::vector<anab::T0>);
    std::unique_ptr< art::Assns<recob::Track, anab::T0> > Trackassn( new art::Assns<recob::Track, anab::T0>);

    // Retrieve CRT hit list
    art::Handle<std::vector<crt::CRTHit>> crtListHandle;
    std::vector<art::Ptr<crt::CRTHit>> crtList;
    if(event.getByLabel(fCrtHitModuleLabel, crtListHandle))
      art::fill_ptr_vector(crtList, crtListHandle);

    // Sort hits into tagger planes
    std::map<std::string, std::vector<crt::CRTHit>> crtHitMap;
    for (auto const& crtHit : (crtList)){
      crtHitMap[crtHit->tagger].push_back(*crtHit);
    }

    // Retrieve track list
    art::Handle< std::vector<recob::Track> > trackListHandle;
    std::vector<art::Ptr<recob::Track> > trackList;
    if (event.getByLabel(fTpcTrackModuleLabel,trackListHandle))
      art::fill_ptr_vector(trackList, trackListHandle);   

    // Get track to hit associations
    art::FindManyP<recob::Hit> findManyHits(trackListHandle, event, fTpcTrackModuleLabel);

    mf::LogInfo("CRTT0Matching")
      <<"Number of reconstructed tracks = "<<trackList.size()<<"\n"
      <<"Number of CRT hits = "<<crtList.size();
   
    if (trackListHandle.isValid() && crtListHandle.isValid() ){
      
      // Loop over all the reconstructed tracks 
      for(size_t track_i = 0; track_i < trackList.size(); track_i++) {

        if (trackList[track_i]->Length() < fMinTrackLength) continue; 

        // Get the TPC of the track
        std::vector<art::Ptr<recob::Hit>> hits = findManyHits.at(trackList[track_i]->ID());
        int tpc = hits[0]->WireID().TPC;

        // If track has already been stitched across the CPA then a t0 has already been associated
        if (tpc != (int)hits[hits.size()-1]->WireID().TPC) continue; 

        // Calculate direction as an average over directions
        size_t nTrackPoints = trackList[track_i]->NumberTrajectoryPoints();
        int endPoint = (int)floor(nTrackPoints*fTrackDirectionFrac);
        double xTotStart = 0; double yTotStart = 0; double zTotStart = 0;
        double xTotEnd = 0; double yTotEnd = 0; double zTotEnd = 0;
        for(int i = 0; i < endPoint; i++){
          xTotStart += trackList[track_i]->DirectionAtPoint(i).X();
          yTotStart += trackList[track_i]->DirectionAtPoint(i).Y();
          zTotStart += trackList[track_i]->DirectionAtPoint(i).Z();
          xTotEnd += trackList[track_i]->DirectionAtPoint(nTrackPoints - (i+1)).X();
          yTotEnd += trackList[track_i]->DirectionAtPoint(nTrackPoints - (i+1)).Y();
          zTotEnd += trackList[track_i]->DirectionAtPoint(nTrackPoints - (i+1)).Z();
        }
        TVector3 startDir = {-xTotStart/endPoint, -yTotStart/endPoint, -zTotStart/endPoint};
        TVector3 endDir = {xTotEnd/endPoint, yTotEnd/endPoint, zTotEnd/endPoint};

        TVector3 start = trackList[track_i]->Vertex<TVector3>();
        TVector3 end = trackList[track_i]->End<TVector3>();

        // ====================== Matching Algorithm ========================== //
        // Get the allowed t0 range
        std::pair<double, double> t0MinMax = t0Alg.TrackT0Range(start.X(), end.X(), tpc); // [us]
        std::vector<std::pair<double, double>> t0Candidates;

        // Loop over the taggers
        for(auto &taggerHits : crtHitMap){
          std::string tagger = taggerHits.first;
       
          // Loop over all the CRT hits
          for(auto &crtHit : taggerHits.second){
            // Check if hit is within the allowed t0 range
            double crtTime = (double)(int)crtHit.ts1_ns * 1e-3; // [us]
            if (!(crtTime >= t0MinMax.first - 10. && crtTime <= t0MinMax.second + 10.)) continue;
            TVector3 crtPoint(crtHit.x_pos, crtHit.y_pos, crtHit.z_pos);
       
            // Calculate the distance between the crossing point and the CRT hit
            double startDist = t0Alg.DistOfClosestApproach(start, startDir, crtHit, tpc, crtTime);
            // If the distance is less than some limit record the time
            if (startDist < fDistanceLimit){ 
              t0Candidates.push_back(std::make_pair(startDist, crtTime));
            }
       
            // Calculate the distance between the crossing point and the CRT hit
            double endDist = t0Alg.DistOfClosestApproach(end, endDir, crtHit, tpc, crtTime);
            // If the distance is less than some limit record the time
            if (endDist < fDistanceLimit){ 
              t0Candidates.push_back(std::make_pair(endDist, crtTime));
            }
       
          }
        }

        // Sort the candidates by distance
        std::sort(t0Candidates.begin(), t0Candidates.end(), [](auto& left, auto& right){
                  return left.first < right.first;});
        double bestTime = -99999;
        double bestDist = -99999;
        if(t0Candidates.size()>0) {
          bestTime = t0Candidates[0].second;
          bestDist = t0Candidates[0].first;
          mf::LogInfo("CRTT0Matching")
            <<"Matched time = "<<bestTime<<" [us] to track "<<trackList[track_i]->ID();
        }

        T0col->push_back(anab::T0(bestTime * 1e3, 0, trackList[track_i]->ID(), (*T0col).size(), bestDist));
        util::CreateAssn(*this, event, *T0col, trackList[track_i], *Trackassn);

      } // Loop over tracks  

    } // Validity check
   
    event.put(std::move(T0col));
    event.put(std::move(Trackassn));
    
  } // CRTT0Matching::produce()


  void CRTT0Matching::endJob()
  {

  } // CRTT0Matching::endJob()


  DEFINE_ART_MODULE(CRTT0Matching)

} // sbnd namespace

namespace {

}
