/////////////////////////////////////////////////////////////////////////////
/// Class:       CRTT0Matching
/// Module Type: producer
/// File:        CRTT0Matching_module.cc
///
/// Author:         Thomas Brooks
/// E-mail address: tbrooks@fnal.gov
///
/// Modified from CRTT0Matching by Thomas Warburton.
/////////////////////////////////////////////////////////////////////////////

// sbndcode includes
#include "sbndcode/CRT/CRTProducts/CRTHit.hh"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <iterator>
#include <algorithm>

// LArSoft
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/AuxDetGeometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/WireGeo.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/SpacePoint.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "larsim/MCCheater/BackTrackerService.h"

// ROOT
#include "TTree.h"
#include "TFile.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TVector3.h"

namespace {
  // Local namespace for local functions

}

namespace sbnd {
  
  class CRTT0Matching : public art::EDProducer {
  public:

    explicit CRTT0Matching(fhicl::ParameterSet const & p);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTT0Matching(CRTT0Matching const &) = delete;
    CRTT0Matching(CRTT0Matching &&) = delete;
    CRTT0Matching & operator = (CRTT0Matching const &) = delete; 
    CRTT0Matching & operator = (CRTT0Matching &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;

    // Selected optional functions.
    void beginJob() override;

    void endJob() override;

    void reconfigure(fhicl::ParameterSet const & p);

    // Utility function that determines the possible x range of a track
    std::pair<double, double> TrackT0Range(double startX, double endX, int tpc);

    // Calculate the distance of closest approach between the end of a track and a crt hit
    double DistOfClosestApproach(TVector3 trackPos, TVector3 trackDir, crt::CRTHit crtHit, int tpc, double t0);

  private:

    // Params got from fcl file.......
    art::InputTag fTpcTrackModuleLabel; ///< name of track producer
    art::InputTag fCrtHitModuleLabel;   ///< name of crt producer
    double        fDistanceLimit;       ///< Maximum distance between projected crossing point and CRT hit
    double        fMinTrackLength;      ///< Minimum track length to perform T0 matching on
    double        fTrackDirectionFrac;  ///< Minimum track length to perform T0 matching on
    bool          fVerbose;             ///< print info

    // Other variables shared between different methods.
    geo::GeometryCore const* fGeometryService;              ///< pointer to Geometry provider
    detinfo::DetectorProperties const* fDetectorProperties; ///< pointer to detector properties provider

  }; // class CRTT0Matching


  CRTT0Matching::CRTT0Matching(fhicl::ParameterSet const & p)
  // Initialize member data here, if know don't want to reconfigure on the fly
  {
    // Call appropriate produces<>() functions here.
    produces< std::vector<anab::T0>               >();
    produces< art::Assns<recob::Track , anab::T0> >();
    
    // Get a pointer to the geometry service provider
    fGeometryService = lar::providerFrom<geo::Geometry>();
    fDetectorProperties = lar::providerFrom<detinfo::DetectorPropertiesService>(); 

    reconfigure(p);
  } // CRTT0Matching()

  void CRTT0Matching::reconfigure(fhicl::ParameterSet const & p)
  {
    fTpcTrackModuleLabel = (p.get<art::InputTag> ("TpcTrackModuleLabel"));
    fCrtHitModuleLabel   = (p.get<art::InputTag> ("CrtHitModuleLabel")); 
    fDistanceLimit       = (p.get<double> ("DistanceLimit")); 
    fMinTrackLength      = (p.get<double> ("MinTrackLength")); 
    fTrackDirectionFrac   = (p.get<double> ("TrackDirectionFrac")); 
    fVerbose             = (p.get<bool> ("Verbose"));
  }

  void CRTT0Matching::beginJob()
  {
    // Implementation of optional member function here.
    art::ServiceHandle<art::TFileService> tfs;

  } // beginJob()

  void CRTT0Matching::produce(art::Event & event)
  {

    if(fVerbose){
      std::cout<<"============================================"<<std::endl
               <<"Run = "<<event.run()<<", SubRun = "<<event.subRun()<<", Event = "<<event.id().event()<<std::endl
               <<"============================================"<<std::endl;
    }

    // Create anab::T0 objects and make association with recob::Track
    std::unique_ptr< std::vector<anab::T0> > T0col( new std::vector<anab::T0>);
    std::unique_ptr< art::Assns<recob::Track, anab::T0> > Trackassn( new art::Assns<recob::Track, anab::T0>);

    // Retrieve CRT hit list
    art::Handle<std::vector<crt::CRTHit>> crtListHandle;
    std::vector<art::Ptr<crt::CRTHit>> crtList;
    if(event.getByLabel(fCrtHitModuleLabel, crtListHandle))
      art::fill_ptr_vector(crtList, crtListHandle);

    // Sort hits into tagger planes
    std::map<std::string, std::vector<crt::CRTHit>> crtHitMap;
    for (auto const& crtHit : (crtList)){
      crtHitMap[crtHit->tagger].push_back(*crtHit);
    }

    // Retrieve track list
    art::Handle< std::vector<recob::Track> > trackListHandle;
    std::vector<art::Ptr<recob::Track> > trackList;
    if (event.getByLabel(fTpcTrackModuleLabel,trackListHandle))
      art::fill_ptr_vector(trackList, trackListHandle);   

    // Get track to hit associations
    art::FindManyP<recob::Hit> findManyHits(trackListHandle, event, fTpcTrackModuleLabel);

    if(fVerbose) std::cout<<"Number of reconstructed tracks = "<<trackList.size()
                          <<"\nNumber of CRT hits = "<<crtList.size()<<"\n";
   
    if (trackListHandle.isValid() && crtListHandle.isValid() ){
      
      // Loop over all the reconstructed tracks 
      for(size_t track_i = 0; track_i < trackList.size(); track_i++) {

        if(fVerbose) std::cout<<"--> Track "<<track_i<<":\n";

        if (trackList[track_i]->Length() < fMinTrackLength){ if(fVerbose) std::cout<<"Track too short!\n"; continue; }
        // Get the TPC of the track
        std::vector<art::Ptr<recob::Hit>> hits = findManyHits.at(trackList[track_i]->ID());
        int tpc = hits[0]->WireID().TPC;
        // If track has already been stitched across the CPA then a t0 has already been associated
        if (tpc != (int)hits[hits.size()-1]->WireID().TPC){ if(fVerbose) std::cout<<"Track has been stitched!\n"; continue; }

        // Calculate direction as an average over directions
        size_t nTrackPoints = trackList[track_i]->NumberTrajectoryPoints();
        int endPoint = (int)floor(nTrackPoints*fTrackDirectionFrac);
        double xTotStart = 0; double yTotStart = 0; double zTotStart = 0;
        double xTotEnd = 0; double yTotEnd = 0; double zTotEnd = 0;
        for(int i = 0; i < endPoint; i++){
          xTotStart += trackList[track_i]->DirectionAtPoint(i)[0];
          yTotStart += trackList[track_i]->DirectionAtPoint(i)[1];
          zTotStart += trackList[track_i]->DirectionAtPoint(i)[2];
          xTotEnd += trackList[track_i]->DirectionAtPoint(nTrackPoints - (i+1))[0];
          yTotEnd += trackList[track_i]->DirectionAtPoint(nTrackPoints - (i+1))[1];
          zTotEnd += trackList[track_i]->DirectionAtPoint(nTrackPoints - (i+1))[2];
        }
        TVector3 startDir = {-xTotStart/endPoint, -yTotStart/endPoint, -zTotStart/endPoint};
        TVector3 endDir = {xTotEnd/endPoint, yTotEnd/endPoint, zTotEnd/endPoint};

        TVector3 start = trackList[track_i]->Vertex();
        TVector3 end = trackList[track_i]->End();

        // ====================== Matching Algorithm ========================== //
        // Get the allowed t0 range
        std::pair<double, double> t0MinMax = TrackT0Range(start.X(), end.X(), tpc);
        std::vector<std::pair<double, double>> t0Candidates;

        // Loop over the taggers
        for(auto &taggerHits : crtHitMap){
          std::string tagger = taggerHits.first;
          if (fVerbose) std::cout<<"Tagger "<<tagger<<"\n";
       
          // Loop over all the CRT hits
          for(auto &crtHit : taggerHits.second){
            // Check if hit is within the allowed t0 range
            double crtTimeTicks = (double)(int)crtHit.ts1_ns/(0.5*10e3); //FIXME proper conversion
            if (!(crtTimeTicks >= t0MinMax.first-20. && crtTimeTicks <= t0MinMax.second+20.)) continue;
            TVector3 crtPoint(crtHit.x_pos, crtHit.y_pos, crtHit.z_pos);
       
            // Calculate the distance between the crossing point and the CRT hit
            double startDist = DistOfClosestApproach(start, startDir, crtHit, tpc, crtTimeTicks);
            // If the distance is less than some limit record the time
            if (startDist < fDistanceLimit){ 
              if (fVerbose) std::cout<<"Match start!\n";
              t0Candidates.push_back(std::make_pair(startDist, crtTimeTicks));
            }
       
            // Calculate the distance between the crossing point and the CRT hit
            double endDist = DistOfClosestApproach(end, endDir, crtHit, tpc, crtTimeTicks);
            // If the distance is less than some limit record the time
            if (endDist < fDistanceLimit){ 
              if (fVerbose) std::cout<<"Match end!\n";
              t0Candidates.push_back(std::make_pair(endDist, crtTimeTicks));
            }
       
          }
        }

        // Sort the candidates by distance
        std::sort(t0Candidates.begin(), t0Candidates.end(), [](auto& left, auto& right){
                  return left.first < right.first;});
        if(fVerbose) std::cout<<"Number of t0 candidates = "<<t0Candidates.size()<<std::endl;
        double bestTime = -99999;
        double bestDist = -99999;
        if(t0Candidates.size()>0) {
          bestTime = t0Candidates[0].second;
          bestDist = t0Candidates[0].first;
          if(fVerbose) std::cout<<"Best time = "<<bestTime<<", bestDist = "<<bestDist<<"\n";
        }

        T0col->push_back(anab::T0(bestTime * 2e3, 0, trackList[track_i]->ID(), (*T0col).size(), bestDist));
        util::CreateAssn(*this, event, *T0col, trackList[track_i], *Trackassn);

      } // Loop over tracks  

    } // Validity check
   
    event.put(std::move(T0col));
    event.put(std::move(Trackassn));
    
  } // produce()

  void CRTT0Matching::endJob()
  {

  }

  // Utility function that determines the possible t0 range of a track
  std::pair<double, double> CRTT0Matching::TrackT0Range(double startX, double endX, int tpc){

    std::pair<double, double> result;
    double Vd = fDetectorProperties->DriftVelocity();
    // Whole track must be within tpc
    // Find which TPC the track hits are detected in
    if(tpc == 0){
      // Lowest |X| is furthest from APA
      double lowX = std::max(startX, endX);
      // xmin is shift from furthest to 0 (the CPA)
      double xmax = 0 - lowX;
      // Highest |X| is closest to APA
      double highX = std::min(startX, endX);
      // xmax is shift from closest to APA
      double xmin = -(2.0*fGeometryService->DetHalfWidth()+3.) - highX;
      double t0max = -2.*xmin/Vd;
      double t0min = -2.*xmax/Vd;
      result = std::make_pair(t0min, t0max);
    }
    else{
      // Lowest |X| is furthest from APA
      double lowX = std::min(startX, endX);
      // xmin is shift from furthest to 0 (the CPA)
      double xmin = 0 - lowX;
      // Highest |X| is closest to APA
      double highX = std::max(startX, endX);
      // xmax is shift from closest to APA
      double xmax = (2.0*fGeometryService->DetHalfWidth()+3.) - highX;
      double t0min = 2.*xmin/Vd;
      double t0max = 2.*xmax/Vd;
      result = std::make_pair(t0min, t0max);
    }
    return result;
  } // CRTT0Matching::TrackT0Range()

  double CRTT0Matching::DistOfClosestApproach(TVector3 trackPos, TVector3 trackDir, crt::CRTHit crtHit, int tpc, double t0){
    double minDist = 99999;

    // Convert the t0 into an x shift
    double shift = 0.5*t0*fDetectorProperties->DriftVelocity();//FIXME proper conversion
    // Apply the shift depending on which TPC the track is in
    if (tpc == 1) trackPos[0] += shift;
    if (tpc == 0) trackPos[0] -= shift;

    TVector3 endPos = trackPos + trackDir;
    double denominator = (endPos - trackPos).Mag();
    // 1D hits should only have a lot of variance in one direction
    if(crtHit.x_err > 50.){
      // Loop over size of hit to find the min dist
      for(int i = 0; i < 20.; i++){
        double xpos = crtHit.x_pos + ((i+1.)/10. - 1.)*crtHit.x_err;
        TVector3 crtPoint(xpos, crtHit.y_pos, crtHit.z_pos);
        double numerator = ((crtPoint - trackPos).Cross(crtPoint-endPos)).Mag();
        double dca = numerator/denominator;
        if(dca < minDist) minDist = dca;
      }
    }
    else if(crtHit.y_err > 50.){
      // Loop over size of hit to find the min dist
      for(int i = 0; i < 20.; i++){
        double ypos = crtHit.y_pos + ((i+1.)/10. - 1.)*crtHit.y_err;
        TVector3 crtPoint(crtHit.x_pos, ypos, crtHit.z_pos);
        double numerator = ((crtPoint - trackPos).Cross(crtPoint-endPos)).Mag();
        double dca = numerator/denominator;
        if(dca < minDist) minDist = dca;
      }
    }
    else if(crtHit.y_err > 50.){
      // Loop over size of hit to find the min dist
      for(int i = 0; i < 20.; i++){
        double zpos = crtHit.z_pos + ((i+1.)/10. - 1.)*crtHit.z_err;
        TVector3 crtPoint(crtHit.x_pos, crtHit.y_pos, zpos);
        double numerator = ((crtPoint - trackPos).Cross(crtPoint-endPos)).Mag();
        double dca = numerator/denominator;
        if(dca < minDist) minDist = dca;
      }
    }
    else{
      TVector3 crtPoint(crtHit.x_pos, crtHit.y_pos, crtHit.z_pos);
      double numerator = ((crtPoint - trackPos).Cross(crtPoint-endPos)).Mag();
      double dca = numerator/denominator;
      if(dca < minDist) minDist = dca;
    }
    return minDist;
  } // CRTT0Matching::DistToOfClosestApproach()
  DEFINE_ART_MODULE(CRTT0Matching)

} // sbnd namespace

namespace {

}
