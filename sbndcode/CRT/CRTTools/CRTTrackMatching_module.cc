/////////////////////////////////////////////////////////////////////////////
/// Class:       CRTTrackMatching
/// Module Type: producer
/// File:        CRTTrackMatching_module.cc
///
/// Author:         Thomas Brooks
/// E-mail address: tbrooks@fnal.gov
///
/// Modified from CRTTrackMatching by Thomas Warburton.
/////////////////////////////////////////////////////////////////////////////

// sbndcode includes
#include "sbndcode/CRT/CRTProducts/CRTTrack.hh"
#include "sbndcode/RecoUtils/RecoUtils.h"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <iterator>
#include <algorithm>

// LArSoft
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/AuxDetGeometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/SpacePoint.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"

// ROOT
#include "TTree.h"
#include "TFile.h"
#include "TVector3.h"

namespace {
  // Local namespace for local functions

}

namespace sbnd {
  
  class CRTTrackMatching : public art::EDProducer {
  public:

    explicit CRTTrackMatching(fhicl::ParameterSet const & p);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTTrackMatching(CRTTrackMatching const &) = delete;
    CRTTrackMatching(CRTTrackMatching &&) = delete;
    CRTTrackMatching & operator = (CRTTrackMatching const &) = delete; 
    CRTTrackMatching & operator = (CRTTrackMatching &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;

    // Selected optional functions.
    void beginJob() override;

    void endJob() override;

    void reconfigure(fhicl::ParameterSet const & p);

  private:

    // Params got from fcl file.......
    art::InputTag fTpcTrackModuleLabel; ///< name of track producer
    art::InputTag fCrtTrackModuleLabel; ///< name of crt producer
    bool          fVerbose;             ///< print info

    // Other variables shared between different methods.
    geo::GeometryCore const* fGeometryService;              ///< pointer to Geometry provider
    detinfo::DetectorProperties const* fDetectorProperties; ///< pointer to detector properties provider
    art::ServiceHandle<geo::AuxDetGeometry> fAuxDetGeoService;
    const geo::AuxDetGeometry* fAuxDetGeo;
    const geo::AuxDetGeometryCore* fAuxDetGeoCore;

  }; // class CRTTrackMatching


  CRTTrackMatching::CRTTrackMatching(fhicl::ParameterSet const & p)
  // Initialize member data here, if know don't want to reconfigure on the fly
  {
    // Call appropriate produces<>() functions here.
    produces< art::Assns<recob::Track , anab::T0> >();
    produces< art::Assns<recob::Track , crt::CRTTrack> >();
    
    // Get a pointer to the geometry service provider
    fGeometryService = lar::providerFrom<geo::Geometry>();
    fDetectorProperties = lar::providerFrom<detinfo::DetectorPropertiesService>(); 
    fAuxDetGeo = &(*fAuxDetGeoService);
    fAuxDetGeoCore = fAuxDetGeo->GetProviderPtr();

    reconfigure(p);
  } // CRTTrackMatching()

  void CRTTrackMatching::reconfigure(fhicl::ParameterSet const & p)
  {
    fTpcTrackModuleLabel = (p.get<art::InputTag> ("TpcTrackModuleLabel"));
    fCrtTrackModuleLabel = (p.get<art::InputTag> ("CrtTrackModuleLabel")); 
    fVerbose             = (p.get<bool> ("Verbose"));
  }

  void CRTTrackMatching::beginJob()
  {
    // Implementation of optional member function here.
    art::ServiceHandle<art::TFileService> tfs;

  } // beginJob()

  void CRTTrackMatching::produce(art::Event & event)
  {

    if(fVerbose){
      std::cout<<"============================================"<<std::endl
               <<"Run = "<<event.run()<<", SubRun = "<<event.subRun()<<", Event = "<<event.id().event()<<std::endl
               <<"============================================"<<std::endl;
    }
    
    // Get TPC tracks
    art::Handle< std::vector<recob::Track> > tpcTrackListHandle;
    std::vector<art::Ptr<recob::Track> > tpcTrackList;
    if (event.getByLabel(fTpcTrackModuleLabel, tpcTrackListHandle))
      art::fill_ptr_vector(tpcTrackList, tpcTrackListHandle);   

    // Get track to hit associations
    art::FindManyP<recob::Hit> findManyHits(tpcTrackListHandle, event, fTpcTrackModuleLabel);

    // Get CRT tracks
    art::Handle< std::vector<crt::CRTTrack> > crtTrackListHandle;
    std::vector<art::Ptr<crt::CRTTrack> > crtTrackList;
    if (event.getByLabel(fCrtTrackModuleLabel, crtTrackListHandle))
      art::fill_ptr_vector(crtTrackList, crtTrackListHandle);

    // Create anab::T0 objects and make association with recob::Track
    std::unique_ptr< art::Assns<recob::Track, anab::T0> >      T0assn(    new art::Assns<recob::Track, anab::T0>);
    std::unique_ptr< art::Assns<recob::Track, crt::CRTTrack> > Trackassn( new art::Assns<recob::Track, crt::CRTTrack>);

    if (tpcTrackListHandle.isValid() && crtTrackListHandle.isValid() ){
      
    } // Validity check
   
    event.put(std::move(T0assn));
    event.put(std::move(Trackassn));
    
  } // produce()

  void CRTTrackMatching::endJob()
  {

  }

  DEFINE_ART_MODULE(CRTTrackMatching)

} // sbnd namespace

namespace {

}
