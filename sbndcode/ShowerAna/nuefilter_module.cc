////////////////////////////////////////////////////////////////////////
// Class:       nuefilter
// Module Type: filter
// File:        nuefilter_module.cc
//
// Generated at Fri Sep  6 04:41:23 2019 by Dominic Barker using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include "larsim/MCCheater/ParticleInventoryService.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "larcorealg/Geometry/BoxBoundedGeo.h"

namespace shower {
  class nuefilter;
}

class shower::nuefilter : public art::EDFilter {
public:
  explicit nuefilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  nuefilter(nuefilter const &) = delete;
  nuefilter(nuefilter &&) = delete;
  nuefilter & operator = (nuefilter const &) = delete;
  nuefilter & operator = (nuefilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;


private:

  // Declare member data here.
  std::string fGenieGenModuleLabel;
  std::vector<geo::BoxBoundedGeo> fActiveVolume; //!< List of active volumes

  bool containedInAV(const TVector3 &v);

};


shower::nuefilter::nuefilter(fhicl::ParameterSet const & pset): art::EDFilter{pset}
// Initialize member data here.
{
  fGenieGenModuleLabel = pset.get<std::string>("GenieGenModuleLabel");

  // setup active volume bounding boxes
  std::vector<fhicl::ParameterSet> AVs =				\
    pset.get<std::vector<fhicl::ParameterSet> >("ActiveVolume");
  for (auto const& AV : AVs) {
    double xmin = AV.get<double>("xmin");
    double ymin = AV.get<double>("ymin");
    double zmin = AV.get<double>("zmin");
    double xmax = AV.get<double>("xmax");
    double ymax = AV.get<double>("ymax");
    double zmax = AV.get<double>("zmax");
    fActiveVolume.emplace_back(xmin, xmax, ymin, ymax, zmin, zmax);
  }


}

bool shower::nuefilter::filter(art::Event & evt)
{
  const art::ServiceHandle<cheat::ParticleInventoryService> particleInventory;
  
  // * MC truth information
  art::Handle<std::vector<simb::MCTruth> > mctruthListHandle;
  std::vector<art::Ptr<simb::MCTruth> > mclist;
  if (evt.getByLabel(fGenieGenModuleLabel,mctruthListHandle))
    art::fill_ptr_vector(mclist, mctruthListHandle);
  
  int numu = 0;
  int nue  = 0;
  //Loop over the neutrinos 
  for(auto const& mc: mclist){

    //Check the interaction is in the active volume.
    if(!containedInAV(mc->GetNeutrino().Nu().Position().Vect())){continue;}

    if(mc->GetNeutrino().Nu().PdgCode() == 12){
      ++nue;
    }
    else{
      ++numu;
    }
  }
  
  if(numu == 0 && nue > 0){return true;} 
  
  return false;

}
		      

//Check if the point is in the Active volume.
bool shower::nuefilter::containedInAV(const TVector3 &v) {
  for (auto const& AV: fActiveVolume) {
    if (AV.ContainsPosition(v)) return true;
  }
  return false;
}



DEFINE_ART_MODULE(shower::nuefilter)
