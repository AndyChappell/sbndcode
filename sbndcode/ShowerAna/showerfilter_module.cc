////////////////////////////////////////////////////////////////////////
// Class:       showerfilter
// Module Type: filter
// File:        showerfilter_module.cc
//
// Generated at Fri Sep  6 04:41:23 2019 by Dominic Barker using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art_root_io/TFileService.h"


#include <memory>

#include "canvas/Persistency/Common/Ptr.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larsim/MCCheater/BackTrackerService.h"


#include "TH1.h"
#include "TH2.h"

namespace shower {
  class showerfilter;
}

class shower::showerfilter : public art::EDFilter {
public:
  explicit showerfilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  showerfilter(showerfilter const &) = delete;
  showerfilter(showerfilter &&) = delete;
  showerfilter & operator = (showerfilter const &) = delete;
  showerfilter & operator = (showerfilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;
  void beginJob();

private:

  TH1D* RecoEffBefore;
  TH1D* RecoEffAfter;

  TH1D* RecoEffBeforeCC;
  TH1D* RecoEffBeforeNC;
  TH1D* RecoEffAfterCC;
  TH1D* RecoEffAfterNC;
  std::map<int,TH1D* > RecoEffBeforeMode;
  std::map<int,TH1D* > RecoEffAfterMode;
  TH1D* RecoLepEffBefore;
  TH1D* RecoLepEffAfter;

  TH1D* RecoLepEffBeforeCC;
  TH1D* RecoLepEffBeforeNC;
  TH1D* RecoLepEffAfterCC;
  TH1D* RecoLepEffAfterNC;
  std::map<int,TH1D* > RecoLepEffBeforeMode;
  std::map<int,TH1D* > RecoLepEffAfterMode;

  TH1D* RecoAVEffBefore;
  TH1D* RecoAVEffAfter;

  TH1D* RecoAVEffBeforeCC;
  TH1D* RecoAVEffBeforeNC;
  TH1D* RecoAVEffAfterCC;
  TH1D* RecoAVEffAfterNC;
  std::map<int,TH1D* > RecoAVEffBeforeMode;
  std::map<int,TH1D* > RecoAVEffAfterMode;
  TH1D* RecoAVLepEffBefore;
  TH1D* RecoAVLepEffAfter;

  TH1D* RecoAVLepEffBeforeCC;
  TH1D* RecoAVLepEffBeforeNC;
  TH1D* RecoAVLepEffAfterCC;
  TH1D* RecoAVLepEffAfterNC;
  std::map<int,TH1D* > RecoAVLepEffBeforeMode;
  std::map<int,TH1D* > RecoAVLepEffAfterMode;

  TH2D* FailedPos2DXY;
  TH2D* FailedPos2DYZ;
  TH2D* FailedPos2DXZ;

  TH2D* FailedPFPPos2DXY;
  TH2D* FailedPFPPos2DYZ;
  TH2D* FailedPFPPos2DXZ;


  TH1D* RecoAVEffAfterMulti;
  TH1D* RecoAVLepEffAfterMulti;
  TH1D* RecoAVEffAfterMultiCC;
  TH1D* RecoAVLepEffAfterMultiCC;
  TH1D* RecoAVEffAfterMultiNC;
  TH1D* RecoAVLepEffAfterMultiNC;

  TH1D* RecoEffAfterPFP;
  TH1D* RecoEffAfterPFPCC;
  TH1D* RecoEffAfterPFPNC;
  std::map<int,TH1D* > RecoEffAfterPFPMode;
  TH1D* RecoLepEffAfterPFP;
  TH1D* RecoLepEffAfterPFPCC;
  TH1D* RecoLepEffAfterPFPNC;
  std::map<int,TH1D* > RecoLepEffAfterPFPMode;


  TH1D* FailedPosDCA;
  TH1D* FailedPFPPosDCA;

  // Declare member data here.
  std::string fPFParticleLabel;
  std::string fShowerModuleLabel;
  std::string fGenieGenModuleLabel;

  art::ServiceHandle<cheat::ParticleInventoryService> particleInventory;
  art::ServiceHandle<art::TFileService> tfs;
  art::ServiceHandle<cheat::BackTrackerService> bt_serv;


  void GetSliceHits(art::Event const& evt, 
		    const art::Ptr<recob::PFParticle>& pfp,
		    std::vector< art::Ptr< recob::Hit> >& pfpHits,
		    std::map<int, art::Ptr<recob::PFParticle> >& pfpMap,
		    art::FindManyP<recob::Cluster>& fmpfc,
		    art::FindManyP<recob::Hit>& fmch);

  double GetTrueNeutrinoEnergy(std::vector< art::Ptr< recob::Hit> >& pfpHits,int& cc, int& mode,double& leptonE, int& key, std::vector<int>& keys);

  std::vector<geo::BoxBoundedGeo> fActiveVolume; //!< List of active volumes

  bool containedInAV(const TVector3 &v);


};

void shower::showerfilter::beginJob() {

  RecoAVEffAfterMulti = tfs->make<TH1D>("RecoAVEffAfterMulti","RecoAVEffAfterMulti",50,0,5000);
  RecoAVLepEffAfterMulti  = tfs->make<TH1D>("RecoAVLepEffAfterMulti","RecoAVLepEffAfterMulti",50,0,5000);
  RecoAVEffAfterMultiCC = tfs->make<TH1D>("RecoAVEffAfterMultiCC","RecoAVEffAfterMultiCC",50,0,5000);
  RecoAVLepEffAfterMultiCC = tfs->make<TH1D>("RecoAVLepEffAfterMultiCC","RecoAVLepEffAfterMultiCC",50,0,5000);
  RecoAVEffAfterMultiNC = tfs->make<TH1D>("RecoAVEffAfterMultiNC","RecoAVEffAfterMultiNC",50,0,5000);
  RecoAVLepEffAfterMultiNC = tfs->make<TH1D>("RecoAVLepEffAfterMultiNC","RecoAVLepEffAfterMultiNC",50,0,5000);

  RecoEffBefore = tfs->make<TH1D>("RecoEffBefore","RecoEffBefore",50,0,5000);
  RecoEffAfter = tfs->make<TH1D>("RecoEffAfter","RecoEffAfter",50,0,5000);
  RecoEffBeforeCC = tfs->make<TH1D>("RecoEffBeforeCC","RecoEffBeforeCC",50,0,5000);
  RecoEffBeforeNC = tfs->make<TH1D>("RecoEffBeforeNC","RecoEffBeforeNC",50,0,5000);
  RecoEffAfterCC = tfs->make<TH1D>("RecoEffAfterCC","RecoEffAfterCC",50,0,5000);
  RecoEffAfterNC = tfs->make<TH1D>("RecoEffAfterNC","RecoEffAfterNC",50,0,5000);

  for(int i=-1; i<14; ++i){
    std::string namestring = "RecoEffBeforeMode" + std::to_string(i);
    const char* name       = namestring.c_str();
    RecoEffBeforeMode[i] = tfs->make<TH1D>(name,name,50,0,5000);
    
    std::string namestringaf = "RecoEffAfterMode" + std::to_string(i);
    const char* nameaf       = namestringaf.c_str();
    RecoEffAfterMode[i]  = tfs->make<TH1D>(nameaf,nameaf,50,0,5000);
 
  }

  RecoLepEffBefore = tfs->make<TH1D>("RecoLepEffBefore","RecoLepEffBefore",50,0,5000);
  RecoLepEffAfter = tfs->make<TH1D>("RecoLepEffAfter","RecoLepEffAfter",50,0,5000);
  RecoLepEffBeforeCC = tfs->make<TH1D>("RecoLepEffBeforeCC","RecoLepEffBeforeCC",50,0,5000);
  RecoLepEffBeforeNC = tfs->make<TH1D>("RecoLepEffBeforeNC","RecoLepEffBeforeNC",50,0,5000);
  RecoLepEffAfterCC = tfs->make<TH1D>("RecoLepEffAfterCC","RecoLepEffAfterCC",50,0,5000);
  RecoLepEffAfterNC = tfs->make<TH1D>("RecoLepEffAfterNC","RecoLepEffAfterNC",50,0,5000);

  for(int i=-1; i<14; ++i){
    std::string namestring = "RecoLepEffBeforeMode" + std::to_string(i);
    const char* name       = namestring.c_str();
    RecoLepEffBeforeMode[i] = tfs->make<TH1D>(name,name,50,0,5000);
    
    std::string namestringaf = "RecoLepEffAfterMode" + std::to_string(i);
    const char* nameaf       = namestringaf.c_str();
    RecoLepEffAfterMode[i]  = tfs->make<TH1D>(nameaf,nameaf,50,0,5000);
   }



  RecoEffAfterPFP = tfs->make<TH1D>("RecoEffAfterPFP","RecoEffAfterPFP",50,0,5000);
  RecoEffAfterPFPCC = tfs->make<TH1D>("RecoEffAfterPFPCC","RecoEffAfterPFPCC",50,0,5000);
  RecoEffAfterPFPNC = tfs->make<TH1D>("RecoEffAfterPFPNC","RecoEffAfterPFPNC",50,0,5000);

  for(int i=-1; i<14; ++i){
    std::string namestringaf = "RecoEffAfterPFPMode" + std::to_string(i);
    const char* nameaf       = namestringaf.c_str();
    RecoEffAfterPFPMode[i]  = tfs->make<TH1D>(nameaf,nameaf,50,0,5000);
 
  }
  RecoLepEffAfterPFP = tfs->make<TH1D>("RecoLepEffAfterPFP","RecoLepEffAfterPFP",50,0,5000);
  RecoLepEffAfterPFPCC = tfs->make<TH1D>("RecoLepEffAfterPFPCC","RecoLepEffAfterPFPCC",50,0,5000);
  RecoLepEffAfterPFPNC = tfs->make<TH1D>("RecoLepEffAfterPFPNC","RecoLepEffAfterPFPNC",50,0,5000);

  for(int i=-1; i<14; ++i){
    std::string namestringaf = "RecoLepEffAfterPFPMode" + std::to_string(i);
    const char* nameaf       = namestringaf.c_str();
    RecoLepEffAfterPFPMode[i]  = tfs->make<TH1D>(nameaf,nameaf,50,0,5000);
   }



  RecoAVEffBefore = tfs->make<TH1D>("RecoAVEffBefore","RecoAVEffBefore",50,0,5000);
  RecoAVEffAfter = tfs->make<TH1D>("RecoAVEffAfter","RecoAVEffAfter",50,0,5000);
  RecoAVEffBeforeCC = tfs->make<TH1D>("RecoAVEffBeforeCC","RecoAVEffBeforeCC",50,0,5000);
  RecoAVEffBeforeNC = tfs->make<TH1D>("RecoAVEffBeforeNC","RecoAVEffBeforeNC",50,0,5000);
  RecoAVEffAfterCC = tfs->make<TH1D>("RecoAVEffAfterCC","RecoAVEffAfterCC",50,0,5000);
  RecoAVEffAfterNC = tfs->make<TH1D>("RecoAVEffAfterNC","RecoAVEffAfterNC",50,0,5000);

  for(int i=-1; i<14; ++i){
    std::string namestring = "RecoAVEffBeforeMode" + std::to_string(i);
    const char* name       = namestring.c_str();
    RecoAVEffBeforeMode[i] = tfs->make<TH1D>(name,name,50,0,5000);
    
    std::string namestringaf = "RecoAVEffAfterMode" + std::to_string(i);
    const char* nameaf       = namestringaf.c_str();
    RecoAVEffAfterMode[i]  = tfs->make<TH1D>(nameaf,nameaf,50,0,5000);
 
  }

  RecoAVLepEffBefore = tfs->make<TH1D>("RecoAVLepEffBefore","RecoAVLepEffBefore",50,0,5000);
  RecoAVLepEffAfter = tfs->make<TH1D>("RecoAVLepEffAfter","RecoAVLepEffAfter",50,0,5000);
  RecoAVLepEffBeforeCC = tfs->make<TH1D>("RecoAVLepEffBeforeCC","RecoAVLepEffBeforeCC",50,0,5000);
  RecoAVLepEffBeforeNC = tfs->make<TH1D>("RecoAVLepEffBeforeNC","RecoAVLepEffBeforeNC",50,0,5000);
  RecoAVLepEffAfterCC = tfs->make<TH1D>("RecoAVLepEffAfterCC","RecoAVLepEffAfterCC",50,0,5000);
  RecoAVLepEffAfterNC = tfs->make<TH1D>("RecoAVLepEffAfterNC","RecoAVLepEffAfterNC",50,0,5000);

  FailedPosDCA = tfs->make<TH1D>("FailedPosDCA","FailedPosDCA",100,0,200);

  FailedPos2DXY = tfs->make<TH2D>("FailedPos2DXY","FailedPos2DXY",200,-200,200,200,-200,200);
  FailedPos2DYZ = tfs->make<TH2D>("FailedPos2DYZ","FailedPos2DYZ",200,-200,200,250,0,500);
  FailedPos2DXZ = tfs->make<TH2D>("FailedPos2DXZ","FailedPos2DXZ",200,-200,200,250,0,500);

  FailedPFPPosDCA = tfs->make<TH1D>("FailedPFPPosDCA","FailedPFPPosDCA",100,0,200);

  FailedPFPPos2DXY = tfs->make<TH2D>("FailedPFPPos2DXY","FailedPFPPos2DXY",200,-200,200,200,-200,200);
  FailedPFPPos2DYZ = tfs->make<TH2D>("FailedPFPPos2DYZ","FailedPFPPos2DYZ",200,-200,200,250,0,500);
  FailedPFPPos2DXZ = tfs->make<TH2D>("FailedPFPPos2DXZ","FailedPFPPos2DXZ",200,-200,200,250,0,500);


  for(int i=-1; i<14; ++i){
    std::string namestring = "RecoAVLepEffBeforeMode" + std::to_string(i);
    const char* name       = namestring.c_str();
    RecoAVLepEffBeforeMode[i] = tfs->make<TH1D>(name,name,50,0,5000);
    
    std::string namestringaf = "RecoAVLepEffAfterMode" + std::to_string(i);
    const char* nameaf       = namestringaf.c_str();
    RecoAVLepEffAfterMode[i]  = tfs->make<TH1D>(nameaf,nameaf,50,0,5000);
   }






}

shower::showerfilter::showerfilter(fhicl::ParameterSet const & pset): art::EDFilter{pset}
// Initialize member data here.
{
  fPFParticleLabel = pset.get<std::string>("PFParticleLabel");
  fShowerModuleLabel = pset.get<std::string>("ShowerModuleLabel");
  fGenieGenModuleLabel = pset.get<std::string>("GenieGenModuleLabel");

  // setup active volume bounding boxes
  std::vector<fhicl::ParameterSet> AVs =				\
    pset.get<std::vector<fhicl::ParameterSet> >("ActiveVolume");
  for (auto const& AV : AVs) {
    double xmin = AV.get<double>("xmin");
    double ymin = AV.get<double>("ymin");
    double zmin = AV.get<double>("zmin");
    double xmax = AV.get<double>("xmax");
    double ymax = AV.get<double>("ymax");
    double zmax = AV.get<double>("zmax");
    fActiveVolume.emplace_back(xmin, xmax, ymin, ymax, zmin, zmax);
  }


}

bool shower::showerfilter::filter(art::Event & evt)
{

  // * MC truth information
  art::Handle<std::vector<simb::MCTruth> > mctruthListHandle;
  std::vector<art::Ptr<simb::MCTruth> > mclist;
  if (evt.getByLabel(fGenieGenModuleLabel,mctruthListHandle))
    art::fill_ptr_vector(mclist, mctruthListHandle);

  std::vector<int> mctruthsinav;
  for(auto const& mctruth: mclist){
    if(!containedInAV(mctruth->GetNeutrino().Nu().Position().Vect())){continue;}
    mctruthsinav.push_back(mctruth.key());
    double leptonE = mctruth->GetNeutrino().Lepton().E();
    double trueEnergy    = mctruth->GetNeutrino().Nu().E();
    int cc    = mctruth->GetNeutrino().CCNC(); 
    int mode    = mctruth->GetNeutrino().Mode();
    RecoAVEffBefore->Fill(trueEnergy*1000);
    RecoAVLepEffBefore->Fill(leptonE*1000);
        
    if(cc!=-999){
      if(cc == 0){
	RecoAVEffBeforeCC->Fill(trueEnergy*1000);
	RecoAVLepEffBeforeCC->Fill(leptonE*1000);
      }
      else{
	RecoAVEffBeforeNC->Fill(trueEnergy*1000);
	RecoAVLepEffBeforeNC->Fill(leptonE*1000);
      }
    }
    if(mode!=-999){
      if(RecoAVEffBeforeMode.find(mode) != RecoAVEffBeforeMode.end()){
	RecoAVEffBeforeMode[mode]->Fill(trueEnergy*1000);
	RecoAVLepEffBeforeMode[mode]->Fill(leptonE*1000);
      }
    }
  }

  //Get the pf particles 
  art::Handle<std::vector<recob::PFParticle> > pfpHandle;
  std::vector<art::Ptr<recob::PFParticle> > pfps;
  if(evt.getByLabel(fPFParticleLabel,pfpHandle))
    {art::fill_ptr_vector(pfps,pfpHandle);}

  //Association between Showers and pfParticle
  art::FindManyP<recob::Shower> fmsh(pfpHandle, evt, fShowerModuleLabel);
  if(!fmsh.isValid()){
    throw cet::exception("ShowerFilter") << " Shower and PF particle association is somehow not valid. Stopping";
    return false;
  }

  //Get the hit and cluster params
  std::vector<art::Handle<std::vector<recob::Hit> > > hitHandles;
  evt.getManyByType(hitHandles);
  std::vector<art::Handle<std::vector<recob::Cluster> > > clusterHandles;
  evt.getManyByType(clusterHandles);

  std::cout << "pfpHandle: " << pfpHandle->size() << " fPFParticleLabel: " << fPFParticleLabel << std::endl;
  std::cout << "pfps.size(): " << pfps.size() << std::endl;
  std::cout << "evt.Event(): " << evt.event() << " Run: " << evt.run() << " SubRun: " << evt.subRun() << std::endl; 

  art::Handle<std::vector<recob::Hit> > hitHandle;
  art::Handle<std::vector<recob::Cluster> > clusterHandle;
  art::FindManyP<recob::Cluster> fmpfc(pfpHandle, evt, fPFParticleLabel);
  if(fmpfc.isValid() && fmpfc.size()>0){
    for (unsigned int fmpfcIter=0; fmpfcIter<fmpfc.size(); fmpfcIter++){
      if (fmpfc.at(fmpfcIter).size()==0) continue;
      evt.get(fmpfc.at(fmpfcIter).front().id(),clusterHandle);
      if (!clusterHandle.isValid()) {
	std::cout<<"Cluster handle not valid one"<<std::endl;
	return false;
      }
      break;
      }
  }
  if (!clusterHandle.isValid()) {
    std::cout<<"Cluster handle not valid"<<std::endl;
      return false;
  }
  
  art::FindManyP<recob::Hit> fmch(clusterHandle, evt, fPFParticleLabel);
  if(fmch.isValid() && fmch.size()>0){
    for (unsigned int fmchIter=0; fmchIter<fmch.size(); fmchIter++){
      if (fmch.at(fmchIter).size()==0) continue;
      evt.get(fmch.at(fmchIter).front().id(),hitHandle);
      if (!hitHandle.isValid()) {
	std::cout<<"Hit handle not valid"<<std::endl;
	return false;
      }
      break;
    }
    if (!hitHandle.isValid()) {
      std::cout<<"Hit handle not valid"<<std::endl;
      return false;
    }
  }
  

  //Loop over fpf and find the neutrinos
  std::vector<art::Ptr<recob::PFParticle> > neutrinos;
  for(auto const& pfp: pfps){
    if(TMath::Abs(pfp->PdgCode()) == 12 || TMath::Abs(pfp->PdgCode()) == 14){
      neutrinos.push_back(pfp);
    }
  }

  //Make the pfp map
  std::map<int, art::Ptr<recob::PFParticle> > pfp_map;
  for(auto const& pfp: pfps){
      pfp_map[pfp->Self()] = pfp;
  }

  std::vector<int> recoed_key;
  std::vector<int> recoed_keys;
  std::vector<int> shower_keys;
  std::vector<int> pfp_keys;

  int neutrino_iter =0;
  for(auto const& neutrino: neutrinos){
    //Get the hits
    std::vector<art::Ptr<recob::Hit> > pfpNeutrinoHits;

    GetSliceHits(evt, neutrino, pfpNeutrinoHits, pfp_map, fmpfc, fmch);

    //Get the truth match
    int cc   = -999;
    int mode = -999;
    double leptonE = -999;
    int key = -999;
    std::vector<int> keys;
    double trueEnergy = GetTrueNeutrinoEnergy(pfpNeutrinoHits,cc,mode,leptonE,key,keys);


    if(key!=-999){
      if(std::find(mctruthsinav.begin(),mctruthsinav.end(),key) != mctruthsinav.end()){
	if(std::find(recoed_key.begin(),recoed_key.end(),key) == recoed_key.end()){
	  recoed_key.push_back(key);
	  RecoAVEffAfter->Fill(trueEnergy*1000);
	  RecoAVLepEffAfter->Fill(leptonE*1000);
	  if(cc!=-999){
	    if(cc == 0){
	      RecoAVEffAfterCC->Fill(trueEnergy*1000);
	      RecoAVLepEffAfterCC->Fill(leptonE*1000);
	    }
	    else{
	      RecoAVEffAfterNC->Fill(trueEnergy*1000);
	      RecoAVLepEffAfterNC->Fill(leptonE*1000);
	    }
	  }
	  if(mode!=-999){
	    if(RecoAVEffAfterMode.find(mode) != RecoAVEffAfterMode.end()){
	      RecoAVEffAfterMode[mode]->Fill(trueEnergy*1000);
	      RecoAVLepEffAfterMode[mode]->Fill(leptonE*1000);
	    }
	  }
	}
      }
    }

    RecoEffBefore->Fill(trueEnergy*1000);
    RecoLepEffBefore->Fill(leptonE*1000);
    if(cc!=-999){
      if(cc == 0){
	RecoEffBeforeCC->Fill(trueEnergy*1000);
	RecoLepEffBeforeCC->Fill(leptonE*1000);
      }
      else{
	RecoEffBeforeNC->Fill(trueEnergy*1000);
	RecoLepEffBeforeNC->Fill(leptonE*1000);
      }
    }
    if(mode!=-999){
      if(RecoEffBeforeMode.find(mode) != RecoEffBeforeMode.end()){
	RecoEffBeforeMode[mode]->Fill(trueEnergy*1000);
	RecoLepEffBeforeMode[mode]->Fill(leptonE*1000);
      }
    }

    const std::vector<long unsigned int> daughters = neutrino->Daughters();
    for(auto const& daughter: daughters){
      //is the daughter a shower.
      if(pfp_map[daughter]->PdgCode() == 11){

	pfp_keys.push_back(key);

	RecoEffAfterPFP->Fill(trueEnergy*1000);
	RecoLepEffAfterPFP->Fill(leptonE*1000);
	if(cc!=-999){
	  if(cc == 0){
	    RecoEffAfterPFPCC->Fill(trueEnergy*1000);
	    RecoLepEffAfterPFPCC->Fill(leptonE*1000);
	  }
	  else{
	    RecoEffAfterPFPNC->Fill(trueEnergy*1000);
	    RecoLepEffAfterPFPNC->Fill(leptonE*1000);
	  }
	}
	if(mode!=-999){
	  if( RecoEffAfterPFPMode.find(mode) !=  RecoEffAfterPFPMode.end()){
	    RecoEffAfterPFPMode[mode]->Fill(trueEnergy*1000);
	    RecoLepEffAfterPFPMode[mode]->Fill(leptonE*1000);
	  }
	}
	


	if(fmsh.at(pfp_map[daughter].key()).size() > 0){

	  shower_keys.push_back(key);


	for(auto const& key_int: keys){
	  if(std::find(mctruthsinav.begin(),mctruthsinav.end(),key_int) != mctruthsinav.end()){
	    if(std::find(recoed_keys.begin(),recoed_keys.end(),key_int) == recoed_keys.end()){
	      recoed_keys.push_back(key_int);
	      RecoAVEffAfterMulti->Fill(trueEnergy*1000);
	      RecoAVLepEffAfterMulti->Fill(leptonE*1000);
	      if(cc!=-999){
		if(cc == 0){
		  RecoAVEffAfterMultiCC->Fill(trueEnergy*1000);
		  RecoAVLepEffAfterMultiCC->Fill(leptonE*1000);
		}
		else{
		  RecoAVEffAfterMultiNC->Fill(trueEnergy*1000);
		  RecoAVLepEffAfterMultiNC->Fill(leptonE*1000);
		}
	      }
	    }
	  }
	}



	RecoEffAfter->Fill(trueEnergy*1000);
	RecoLepEffAfter->Fill(leptonE*1000);
	if(cc!=-999){
	  if(cc == 0){
	    RecoEffAfterCC->Fill(trueEnergy*1000);
	    RecoLepEffAfterCC->Fill(leptonE*1000);
	  }
	  else{
	    RecoEffAfterNC->Fill(trueEnergy*1000);
	    RecoLepEffAfterNC->Fill(leptonE*1000);
	  }
	}
	if(mode!=-999){
	  if( RecoEffAfterMode.find(mode) !=  RecoEffAfterMode.end()){
	    RecoEffAfterMode[mode]->Fill(trueEnergy*1000);
	    RecoLepEffAfterMode[mode]->Fill(leptonE*1000);
	  }
	}
	
	++neutrino_iter;
	break;
	}
      }
    }
  }


  std::cout << "mctruthsinav: " << mctruthsinav.size() << " " <<  recoed_key.size() << std::endl; 
  for(auto const& key: mctruthsinav){

      if(std::find(pfp_keys.begin(),pfp_keys.end(),key) == pfp_keys.end()){
      std::cout << "evt.Event(): " << evt.event() << " Run: " << evt.run() << " SubRun: " << evt.subRun() << std::endl; 
      std::cout << "MCTruth not Reco" << std::endl;
      for(auto const& mc:  mclist){
	if((int) mc.key() ==  key){
	  FailedPFPPos2DXY->Fill(mc->GetNeutrino().Nu().Position().Vect().X(),mc->GetNeutrino().Nu().Position().Vect().Y()); 
	  FailedPFPPos2DYZ->Fill(mc->GetNeutrino().Nu().Position().Vect().Y(),mc->GetNeutrino().Nu().Position().Vect().Z());
	  FailedPFPPos2DXZ->Fill(mc->GetNeutrino().Nu().Position().Vect().X(),mc->GetNeutrino().Nu().Position().Vect().Z());

	  float xmin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().X() - 200);
	  float ymin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Y() - 200);
	  float zmin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Z() - 0);
	  


	  if(TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().X() - 200) > TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().X() + 200)){
	    xmin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().X() + 200);
	  }
	  if(TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Y() - 200) > TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Y() + 200)){
	    ymin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Y() + 200);
	  }
	  if(TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Z()) > TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Y() - 500)){
	    zmin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Z() -500);
	  }

	  if(xmin > ymin){
	    if(ymin < zmin){
	      FailedPFPPosDCA->Fill(ymin);
	    }
	    else{
	      FailedPFPPosDCA->Fill(zmin);
	    }
	  }
	  else{
	    if(xmin < zmin){
	      FailedPFPPosDCA->Fill(xmin);
	    }
	    else{
	      FailedPFPPosDCA->Fill(zmin);
	    }
	  }

	    
	  std::cout << "one below has the key" << std::endl;
	}
	std::cout << mc << std::endl;
      }
    }

    if(std::find(shower_keys.begin(),shower_keys.end(),key) == shower_keys.end()){
      std::cout << "evt.Event(): " << evt.event() << " Run: " << evt.run() << " SubRun: " << evt.subRun() << std::endl; 
      std::cout << "MCTruth not Reco" << std::endl;
      for(auto const& mc:  mclist){
	if((int) mc.key() ==  key){
	  FailedPos2DXY->Fill(mc->GetNeutrino().Nu().Position().Vect().X(),mc->GetNeutrino().Nu().Position().Vect().Y()); 
	  FailedPos2DYZ->Fill(mc->GetNeutrino().Nu().Position().Vect().Y(),mc->GetNeutrino().Nu().Position().Vect().Z());
	  FailedPos2DXZ->Fill(mc->GetNeutrino().Nu().Position().Vect().X(),mc->GetNeutrino().Nu().Position().Vect().Z());

	  float xmin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().X() - 200);
	  float ymin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Y() - 200);
	  float zmin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Z() - 0);
	  


	  if(TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().X() - 200) > TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().X() + 200)){
	    xmin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().X() + 200);
	  }
	  if(TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Y() - 200) > TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Y() + 200)){
	    ymin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Y() + 200);
	  }
	  if(TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Z()) > TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Y() - 500)){
	    zmin = TMath::Abs(mc->GetNeutrino().Nu().Position().Vect().Z() -500);
	  }

	  if(xmin > ymin){
	    if(ymin < zmin){
	      FailedPosDCA->Fill(ymin);
	    }
	    else{
	      FailedPosDCA->Fill(zmin);
	    }
	  }
	  else{
	    if(xmin < zmin){
	      FailedPosDCA->Fill(xmin);
	    }
	    else{
	      FailedPosDCA->Fill(zmin);
	    }
	  }

	    
	  std::cout << "one below has the key" << std::endl;
	}
	std::cout << mc << std::endl;
      }
    }
  }

  if(neutrino_iter > 0){
    return true;
  }


  //Only Keep events where a reco shower exists. 
  return false;
}




void shower::showerfilter::GetSliceHits(art::Event const& evt,
					const art::Ptr<recob::PFParticle>& pfp, 
					std::vector< art::Ptr< recob::Hit> >& pfpHits,
					std::map<int, art::Ptr<recob::PFParticle> >& pfpMap,
					art::FindManyP<recob::Cluster>& fmpfc,
					art::FindManyP<recob::Hit>& fmch){

  // Get the hits from the PFParticle
  const std::vector< art::Ptr< recob::Cluster> >& clusters = fmpfc.at(pfp.key());
  for (const auto& cluster: clusters){
    const std::vector< art::Ptr< recob::Hit> >& hits = fmch.at(cluster.key());
    pfpHits.insert(pfpHits.end(), hits.begin(), hits.end());
  }
  
  // Get the daughters
  const std::vector<long unsigned int> daughters = pfp->Daughters();
  for (const auto daughterIter: daughters){
    art::Ptr<recob::PFParticle> daughter =  pfpMap.at(daughterIter);
    // Get the hits from the daughters
    GetSliceHits(evt, daughter, pfpHits, pfpMap, fmpfc,fmch);
  }
  return;
}


double shower::showerfilter::GetTrueNeutrinoEnergy(std::vector< art::Ptr< recob::Hit> >& pfpHits, int& isCC, int& mode, double& leptonE, int& key, std::vector<int>& keys){

  std::map<int,int> particleHits;
  for (const auto& hit: pfpHits){
    int trackID     = 0;
    float hitEnergy = 0;
    std::vector<sim::TrackIDE> trackIDEs = bt_serv->HitToTrackIDEs(hit);
    for (const auto& ide: trackIDEs) {
      if (ide.energy > hitEnergy){
        hitEnergy = ide.energy;
        trackID   = TMath::Abs(ide.trackID);
	int mckey = particleInventory->TrackIdToMCTruth_P(trackID).key();
	if(std::find(keys.begin(), keys.end(), mckey) == keys.end()){keys.push_back(mckey);}
      }
    }
    ++particleHits[trackID];
  }

  int max_track_hits = -999;
  int max_track_id   = -999;
  for(auto const& trackId: particleHits){
    if(trackId.second > max_track_hits){
      max_track_id = trackId.first;
    }
  }

  if(max_track_id == -999){return -999;}

  const art::Ptr< simb::MCTruth > mc = particleInventory->TrackIdToMCTruth_P(max_track_id);

  isCC    = mc->GetNeutrino().CCNC();
  mode    = mc->GetNeutrino().Mode();
  leptonE =  mc->GetNeutrino().Lepton().E(); 
  key = mc.key();

  return mc->GetNeutrino().Nu().E();
}

//Check if the point is in the Active volume.
bool shower::showerfilter::containedInAV(const TVector3 &v) {
  for (auto const& AV: fActiveVolume) {
    if (AV.ContainsPosition(v)) return true;
  }
  return false;
}



		      
DEFINE_ART_MODULE(shower::showerfilter)
