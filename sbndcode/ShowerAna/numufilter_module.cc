////////////////////////////////////////////////////////////////////////
// Class:       numufilter
// Module Type: filter
// File:        numufilter_module.cc
//
// Generated at Fri Sep  6 04:41:23 2019 by Dominic Barker using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include "larsim/MCCheater/ParticleInventoryService.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "larcorealg/Geometry/BoxBoundedGeo.h"

namespace shower {
  class numufilter;
}

class shower::numufilter : public art::EDFilter {
public:
  explicit numufilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  numufilter(numufilter const &) = delete;
  numufilter(numufilter &&) = delete;
  numufilter & operator = (numufilter const &) = delete;
  numufilter & operator = (numufilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;


private:

  // Declare member data here.
  std::string fGenieGenModuleLabel;
  std::vector<geo::BoxBoundedGeo> fActiveVolume; //!< List of active volumes

  bool containedInAV(const TVector3 &v);


};


shower::numufilter::numufilter(fhicl::ParameterSet const & pset): art::EDFilter{pset}
// Initialize member data here.
{
  fGenieGenModuleLabel = pset.get<std::string>("GenieGenModuleLabel");

  // setup active volume bounding boxes
  std::vector<fhicl::ParameterSet> AVs =				\
    pset.get<std::vector<fhicl::ParameterSet> >("ActiveVolume");
  for (auto const& AV : AVs) {
    double xmin = AV.get<double>("xmin");
    double ymin = AV.get<double>("ymin");
    double zmin = AV.get<double>("zmin");
    double xmax = AV.get<double>("xmax");
    double ymax = AV.get<double>("ymax");
    double zmax = AV.get<double>("zmax");
    fActiveVolume.emplace_back(xmin, xmax, ymin, ymax, zmin, zmax);
  }


}

bool shower::numufilter::filter(art::Event & evt)
{
  const art::ServiceHandle<cheat::ParticleInventoryService> particleInventory;
  
  // * MC truth information
  art::Handle<std::vector<simb::MCTruth> > mctruthListHandle;
  std::vector<art::Ptr<simb::MCTruth> > mclist;
  if (evt.getByLabel(fGenieGenModuleLabel,mctruthListHandle))
    art::fill_ptr_vector(mclist, mctruthListHandle);
  
  int numu = 0;
  int nue  = 0;
  //Loop over the neutrinos 
  for(auto const& mc: mclist){

    std::cout << "Type: " << mc->GetNeutrino().Nu().PdgCode() << std::endl;
    
    //Check the interaction is in the active volume.
    if(!containedInAV(mc->GetNeutrino().Nu().Position().Vect())){std::cout << "not in AV" << std::endl; continue;}

    if(mc->GetNeutrino().Nu().PdgCode() == 12){
      ++nue;
    }
    else{
      ++numu;
    }
  }

  std::cout << "nue num: " << nue << " numu num: " << numu << std::endl;
  
  if(nue == 0 && numu > 0){return true;} 
  
  return false;

}
		      

//Check if the point is in the Active volume.
bool shower::numufilter::containedInAV(const TVector3 &v) {
  for (auto const& AV: fActiveVolume) {
    if (AV.ContainsPosition(v)) return true;
  }
  return false;
}



DEFINE_ART_MODULE(shower::numufilter)
