//INCLUDES
//#include <vector>
//#include "TH2F.h"

//DEFINITIONS
TH2F *h_PidEnergy[3]; // PID vs energy for each plane and particle

// PIDA for each plane and particle
TH1F *h_Pida[3];

// PID efficiency vs energy for each plane and particle
TGraphAsymmErrors *h_EffEnergy[3];
TH1F *h_EffEnergy_pass[3]; // Count correct IDs
TH1F *h_EffEnergy_tot[3]; // Count all IDs, divide later

// Total efficiencies 
double efficiency[3];
double total[3];

// Counter for number of events removed in cuts
int nCut[3];

// Histogram of dE/dx vs res range for each plane and particle
TH2F *h_dEdxVsResRg[3];

TH1F *h_dEdx[3];
TH1F *h_ResRg[3];

TProfile *dedx_range_mu;

// Vectors to store all histograms and graphs
std::vector<TH2*> v_AllTH2;
std::vector<TH1*> v_AllTH1;
std::vector<TGraphAsymmErrors*> v_AllTGraph;

void calc_pideff_Begin(TTree*){

  //Loop over planes
  for (int plane_i = 0; plane_i < 3; plane_i++){

      double min_p = 0.0; double max_p = 0.0; std::string particle = "other"; int col = 1;
      if(part_i==0) {min_p = 0.1; max_p = 1.26; particle = "muon"; col = 4;} //Muons
      if(part_i==1) {min_p = 0.1; max_p = 2.25; particle = "pion"; col = 2;} //Pions
      if(part_i==2) {min_p = 0.2; max_p = 2.25; particle = "proton"; col = 8;} //Protons

      TString h_PidEnergy_name = Form("h_PidEnergy_plane%i_%s", plane_i, particle.c_str()); 
      h_PidEnergy[plane_i] = new TH2F(h_PidEnergy_name, "", 10, min_p, max_p, 10, 0, 5);
      h_PidEnergy[plane_i]->GetXaxis()->SetTitle("Momentum (GeV)");
      h_PidEnergy[plane_i]->GetYaxis()->SetTitle("#mu      #pi      K       p     ");
      h_PidEnergy[plane_i]->GetYaxis()->SetTitleOffset(0.3);
      h_PidEnergy[plane_i]->GetYaxis()->SetLabelSize(0.0);
      v_AllTH2.push_back(h_PidEnergy[plane_i]);
    
      TString h_Pida_name = Form("h_Pida_plane%i_%s", plane_i, particle.c_str()); 
      h_Pida[plane_i] = new TH1F(h_Pida_name, "", 100, 0, 30);
      h_Pida[plane_i]->GetXaxis()->SetTitle("PIDA Value");
      h_Pida[plane_i]->GetYaxis()->SetTitle("Number Events");
      v_AllTH1.push_back(h_Pida[plane_i]);

      TString h_EffEnergy_name = Form("h_EffEnergy_plane%i_%s", plane_i, particle.c_str());
      h_EffEnergy[plane_i] = new TGraphAsymmErrors();
      h_EffEnergy[plane_i]->SetName(h_EffEnergy_name);
      h_EffEnergy[plane_i]->SetTitle(";Momentum (GeV);PID Efficiency (%)");
      h_EffEnergy[plane_i]->SetMarkerStyle(8);
      h_EffEnergy[plane_i]->SetMarkerColor(col);
      h_EffEnergy[plane_i]->SetLineColor(col);
      h_EffEnergy[plane_i]->SetLineWidth(3); 
      h_EffEnergy[plane_i]->GetYaxis()->SetTitleOffset(0.65);
      h_EffEnergy[plane_i]->Draw("ap");
      v_AllTGraph.push_back(h_EffEnergy[plane_i]);
     
      TString h_EffEnergy_pass_name = Form("h_EffEnergy_pass_plane%i_%s", plane_i, particle.c_str());
      h_EffEnergy_pass[plane_i][part_i] = new TH1F(h_EffEnergy_pass_name, "", 10, min_p, max_p);
      TString h_EffEnergy_tot_name = Form("h_EffEnergy_tot_plane%i_%s", plane_i, particle.c_str());
      h_EffEnergy_tot[plane_i][part_i] = new TH1F(h_EffEnergy_tot_name, "", 10, min_p, max_p);
     
      efficiency[plane_i][part_i]=0.0;
      total[plane_i][part_i]=0.0;

      TString h_dEdxVsResRg_name = Form("h_dEdxVsResRg_plane%i_%s", plane_i, particle.c_str());
      h_dEdxVsResRg[plane_i][part_i] = new TH2F(h_dEdxVsResRg_name, "", 100, 0, 25, 100, 0, 30);
      h_dEdxVsResRg[plane_i][part_i]->GetXaxis()->SetTitle("Residual range (cm)");
      h_dEdxVsResRg[plane_i][part_i]->GetYaxis()->SetTitle("dE/dx (MeV/cm)");
      v_AllTH2.push_back(h_dEdxVsResRg[plane_i][part_i]);

      nCut[plane_i][part_i]=0;

      TString h_dEdx_name = Form("h_dEdx_plane%i_%s", plane_i, particle.c_str()); 
      h_dEdx[plane_i][part_i] = new TH1F(h_dEdx_name, ";dE/dx (MeV/cm);Events", 100, 0, 20);
      v_AllTH1.push_back(h_dEdx[plane_i][part_i]);

      TString h_ResRg_name = Form("h_ResRg_plane%i_%s", plane_i, particle.c_str()); 
      h_ResRg[plane_i][part_i] = new TH1F(h_ResRg_name, ";Residual range (cm);Events", 100, 0, 30);
      v_AllTH1.push_back(h_ResRg[plane_i][part_i]);

  }

  TFile *file = TFile::Open("dEdxrestemplates.root");
  dedx_range_mu  = (TProfile*)file->Get("dedx_range_mu");
  TFile *file2 = new TFile("output_pid.root","RECREATE");

}

int calc_pideff() {

  //Check how many g4 tracks correspond to the incoming particle
  int nMerged = 0;
  for (int i = 0; i < geant_list_size; i++){
    if (MergedId[i]==MergedId[0]) nMerged++;
  }

  // Calculate the chi2/ndf for a fit to a horizontal line to check if chi2 method is valid
  std::vector<std::vector<double>> chi2null;
  std::vector<std::vector<double>> chi2mip;
  std::vector<std::vector<int>> mippid;
  std::vector<std::vector<bool>> step;
  std::vector<std::vector<bool>> isValid;
  
  //Loop over reco tracks in event
  for (int track_i = 0; track_i < ntracks_pmalgtrackmaker; track_i++){
    //Loop over planes
    std::vector<double> chi2planes;
    std::vector<double> chi2mip_pln;
    std::vector<int> mippid_pln;
    std::vector<bool> step_pln;
    std::vector<bool> isValid_pln;
    
      int plane_i = 2;
      //Loop over hits in tracks
      double chi2 = 0;
      double chi2mu = 0; double chi2pi = 0; double chi2p = 0; double chi2k = 0;
      double chi2mipmu = 0; double chi2mippi = 0; double chi2mipp = 0;
      int npt = 0;

      std::vector<std::pair<double,double>> v_resrgdedx;

      double dedx_int = 0;
      double int_pts = 0;
      for (int hit_i = 0; hit_i < ntrkhits_pmalgtrackmaker[track_i][plane_i]; hit_i++){
        if (trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]>30) continue;
        v_resrgdedx.push_back(std::make_pair(trkresrg_pmalgtrackmaker[track_i][plane_i][hit_i],trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]));
        //if (trkresrg_pmalgtrackmaker[track_i][plane_i][hit_i]>25) continue;
        //if (trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]>3) continue;
        //dedx_int += trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i];
        //int_pts ++;
      }
      double dedx_mean = 0;//dedx_int/int_pts;
      double dedx_err = 0;
      /*for (int hit_i = 0; hit_i < ntrkhits_pmalgtrackmaker[track_i][plane_i]; hit_i++){
        if (trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]>30) continue;
        if (trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]>3) continue;
        //if (trkresrg_pmalgtrackmaker[track_i][plane_i][hit_i]>25) continue;
        dedx_err += pow(trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]-dedx_mean,2);
      }
      dedx_err = TMath::Sqrt(dedx_err/((int_pts-1)));*/

      std::sort(v_resrgdedx.rbegin(), v_resrgdedx.rend());
      if (v_resrgdedx.size()>20){
        //if (v_resrgdedx[0].first>20){
          for (int hit_i = 0; hit_i < 10; hit_i ++){
            dedx_int += v_resrgdedx[hit_i].second;
            int_pts ++;
          }
          dedx_mean = dedx_int/int_pts;
          for (int hit_i = 0; hit_i < 10; hit_i ++){
            dedx_err += pow(v_resrgdedx[hit_i].second-dedx_mean,2);
          }
          dedx_err = TMath::Sqrt(dedx_err/((int_pts-1)));
        //} else { dedx_mean = 3; dedx_err = 0.5; }
      } else { dedx_mean = 3; dedx_err = 1; }
      std::sort(v_resrgdedx.begin(), v_resrgdedx.end());
      
/*      bool hasStep = 0;
      for (int hit_i = 0; hit_i < v_resrgdedx.size()-4; hit_i++){
        //Find a peak
        if (hit_i+4>v_resrgdedx.size()) continue;
        if (v_resrgdedx[hit_i+1].second-v_resrgdedx[hit_i].second>2){
          //Look at the next 3 points
          if (v_resrgdedx[hit_i+2].second-v_resrgdedx[hit_i+1].second<-1.5) {}
          else if (v_resrgdedx[hit_i+3].second-v_resrgdedx[hit_i+2].second<-1.5) {}
          else if (v_resrgdedx[hit_i+4].second-v_resrgdedx[hit_i+3].second<-1.5) {}
          else hasStep = 1;
        }
      }
      step_pln.push_back(hasStep);

      if (v_resrgdedx.size()>20){
        for (int hit_i = 0; hit_i < 10; hit_i++){
          if(v_resrgdedx[hit_i].second>dedx_mean+(0.5*dedx_err)||v_resrgdedx[hit_i].second<dedx_mean-(0.5*dedx_err)) continue;
          double err = 0.04231+0.0001783*v_resrgdedx[hit_i].second*v_resrgdedx[hit_i].second;
          err *= v_resrgdedx[hit_i].second;
          chi2 += pow((v_resrgdedx[hit_i].second-dedx_mean)/std::sqrt(pow(dedx_err,2)+pow(err,2)),2);
          npt++;
        }
      }
      else{*/   
      for (int hit_i = 0; hit_i < ntrkhits_pmalgtrackmaker[track_i][plane_i]; hit_i++){
        //Calculate the chi2 with a horizontal line at 3 MeV/cm
        if (trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]>1000) continue;
        double maxrr = 14;
        if (plane_i == 0) maxrr = 2;
        if (plane_i == 2) maxrr = 20;
        if (trkresrg_pmalgtrackmaker[track_i][plane_i][hit_i]>maxrr||trkresrg_pmalgtrackmaker[track_i][plane_i][hit_i]<0.3) continue;
        int bin = dedx_range_pro->FindBin(trkresrg_pmalgtrackmaker[track_i][plane_i][hit_i]);
        // Needs to be done over the the same range as dedx_range_pro
        double err = 0.04231+0.0001783*trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]*trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i];
        err *= trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i];
        chi2 += pow((trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]-3)/std::sqrt(pow(1,2)+pow(err,2)),2); // Chi2 with horizontal line at 3+/-0.7 MeV/cm
        chi2mu += pow((trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]-dedx_range_mu->GetBinContent(bin))/std::sqrt(pow(dedx_range_mu->GetBinError(bin),2)+pow(err,2)),2);
        chi2pi += pow((trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]-dedx_range_pi->GetBinContent(bin))/std::sqrt(pow(dedx_range_pi->GetBinError(bin),2)+pow(err,2)),2);
        chi2p += pow((trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]-dedx_range_pro->GetBinContent(bin))/std::sqrt(pow(dedx_range_pro->GetBinError(bin),2)+pow(err,2)),2);
        chi2k += pow((trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]-dedx_range_ka->GetBinContent(bin))/std::sqrt(pow(dedx_range_ka->GetBinError(bin),2)+pow(err,2)),2);
        //chi2mipp += pow((trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]-4.43)/std::sqrt(pow(0.29,2)+pow(err,2)),2);
        //chi2mippi += pow((trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]-2.58)/std::sqrt(pow(0.4,2)+pow(err,2)),2);
        //chi2mipmu += pow((trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]-2.38)/std::sqrt(pow(0.38,2)+pow(err,2)),2);
        npt++;
      }
      //}

      chi2planes.push_back(chi2/npt);
      double maxchi2 = 5.5;
      if (plane_i ==0) maxchi2 = 9;
      if (plane_i ==2) maxchi2 = 5;
      if(chi2mu/npt>maxchi2 && chi2pi/npt>maxchi2 && chi2p/npt>maxchi2 && chi2k/npt>maxchi2 && chi2mu<chi2pi && chi2mu<chi2k &&chi2mu<chi2p) isValid_pln.push_back(0);
      else isValid_pln.push_back(1);
      //if (chi2mipmu < chi2mippi && chi2mipmu < chi2mipp){ chi2mip_pln.push_back(chi2mipmu/npt); mippid_pln.push_back(13); }
      //else if (chi2mippi < chi2mipmu && chi2mippi < chi2mipp){ chi2mip_pln.push_back(chi2mippi/npt); mippid_pln.push_back(211); }
      //else if (chi2mipp < chi2mipmu && chi2mipp < chi2mippi){ chi2mip_pln.push_back(chi2mipp/npt); mippid_pln.push_back(2212); }
      //else { chi2mip_pln.push_back(-99999); mippid_pln.push_back(-99999); }

    }   
    chi2null.push_back(chi2planes);
    isValid.push_back(isValid_pln);
    //chi2mip.push_back(chi2mip_pln);
    //mippid.push_back(mippid_pln);
    //step.push_back(step_pln);
  }

  // Loop over all the tracks
  for (int track_i = 0; track_i < ntracks_pmalgtrackmaker; track_i++){
    // Here there is only one primary particle, in this case the primary particle is always top of the list
    for (int plane_i = 0; plane_i < 3; plane_i++){

      //plane_i = trkpidbestplane_pmalgtrackmaker[track_i];

      // Convert the true pdg code to an index
      int part_i = -1;
      if (abs(trkpdgtruth_pmalgtrackmaker[track_i][plane_i])==13) part_i=0;
      else if (abs(trkpdgtruth_pmalgtrackmaker[track_i][plane_i])==211) part_i=1;
      else if (abs(trkpdgtruth_pmalgtrackmaker[track_i][plane_i])==2212) part_i=2;

      // Get the corresponding true momentum and geant index of the reco track
      double mom = 0;
      int g4i = -1;
      for (int j = 0; j < geant_list_size; j++){
        if (trkidtruth_pmalgtrackmaker[track_i][plane_i]==TrackId[j]){ mom = P[j]; g4i =j; }
      }

      // Check if reco track is within 10 cm of the AV boundary
      bool isContained = 0;
      if (trkstartx_pmalgtrackmaker[track_i] > 10 && trkstartx_pmalgtrackmaker[track_i] < 190 &&
          trkendx_pmalgtrackmaker[track_i] > 10 && trkendx_pmalgtrackmaker[track_i] < 190 &&
          trkstarty_pmalgtrackmaker[track_i] > -190 && trkstarty_pmalgtrackmaker[track_i] < 190 &&
          trkendy_pmalgtrackmaker[track_i] > -190 && trkendy_pmalgtrackmaker[track_i] < 190 &&
          trkstartz_pmalgtrackmaker[track_i] > 10 && trkstartz_pmalgtrackmaker[track_i] < 490 &&
          trkendz_pmalgtrackmaker[track_i] > 10 && trkendz_pmalgtrackmaker[track_i] < 490) isContained = 1;

      //---------------------------------- CUTS ------------------------------------//

      // Cut any tracks which don't correspond to true muons, pions or protons
      if(part_i==-1) continue;
 
      // Cut any tracks with invalid IDs
      if (trkidtruth_pmalgtrackmaker[track_i][plane_i]==-1) continue;

      // Cut any events where the incoming particle corresponds to multiple truth tracks
      //if (nMerged>1) continue;

      // Cut any tracks which don't match geant tracks
      if (g4i == -1) continue;

      // Cut any tracks which don't correspond to the primary particle
      if (MergedId[g4i]!=MergedId[0]) continue;

      //if (trkpidchi_pmalgtrackmaker[track_i][plane_i]>4){ nCut[0][part_i]++; continue; }
      if (isValid[track_i][plane_i]) { nCut[plane_i][part_i]++; continue; }

      // Cut any tracks with too few hits
      //if (ntrkhits_pmalgtrackmaker[track_i][plane_i] < 4){ nCut[0][part_i]++; continue; }
 
      // Cut any tracks which don't match the true length, to avoid joined tracks and delta rays
      //if (abs(pathlen[g4i]-trkrange_pmalgtrackmaker[track_i])>10) continue;

      // Cut any reco tracks which start or end too close to the edge of the TPC
      //if (!isContained){ nCut[0][part_i]++; continue; }
 
      // Cut any tracks which are best described by a straight line, i.e don't look like stopping particles
      //if(chi2null[track_i][plane_i]<trkpidchi_pmalgtrackmaker[track_i][plane_i]){ nCut[0][part_i]++; continue; }

      // Cut any tracks best described by a MIP muon, pion or proton
      //if(chi2mip[track_i][plane_i]<trkpidchi_pmalgtrackmaker[track_i][plane_i]){ nCut[plane_i][part_i]++; continue; }

      // Cut any tracks with steps in dE/dx
      //if(step[track_i][plane_i]) { nCut[plane_i][part_i]++; continue; }


      //--------------------------------- END CUTS ----------------------------------//
 
      int pdgcode = trkpidpdg_pmalgtrackmaker[track_i][plane_i];
      if (pdgcode>0){
        //Define different codes for better looking plot (muon = 1, pion = 2, kaon = 3, proton = 4)
        int pidcode = 0;
        if (pdgcode == 13) pidcode = 1;
        else if (pdgcode == 211) pidcode = 2;
        else if (pdgcode == 321) pidcode = 3;
        else if (pdgcode == 2212) pidcode = 4;
        // Fill PID vs momentum histogram
        h_PidEnergy[plane_i][part_i]->Fill(mom,pidcode);
      }

      // Calculate and plot efficiency
      if ( trkpidpdg_pmalgtrackmaker[track_i][plane_i] == abs(trkpdgtruth_pmalgtrackmaker[track_i][plane_i]) ){
        h_EffEnergy_pass[plane_i][part_i]->Fill(mom);
        efficiency[plane_i][part_i]++;
      }
      h_EffEnergy_tot[plane_i][part_i]->Fill(mom);
      total[plane_i][part_i]++;

      //Fill PIDA distributions
      h_Pida[plane_i][part_i]->Fill(trkpidpida_pmalgtrackmaker[track_i][plane_i]);

      double dedx_mean = 0;
      int dedx_npt = 0;
      // dE/dx vs res range curves
      for (int hit_i = 0; hit_i < ntrkhits_pmalgtrackmaker[track_i][plane_i]; hit_i++){
        if(trkresrg_pmalgtrackmaker[track_i][plane_i][hit_i] > 0){
          h_dEdxVsResRg[plane_i][part_i]->Fill(trkresrg_pmalgtrackmaker[track_i][plane_i][hit_i],trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]);
          //h_dEdx[plane_i][part_i]->Fill(trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i]);
          dedx_mean += trkdedx_pmalgtrackmaker[track_i][plane_i][hit_i];
          dedx_npt++;
          h_ResRg[plane_i][part_i]->Fill(trkresrg_pmalgtrackmaker[track_i][plane_i][hit_i]);
        }
      }
      h_dEdx[plane_i][part_i]->Fill(dedx_mean/trkrange_pmalgtrackmaker[track_i][plane_i]);

    }// End of loop over planes
  }// End of loop over tracks

  return 0;
}

void calc_pideff_Terminate(){

  for (int plane_i = 0; plane_i < 3; plane_i++){
    for (int part_i = 0; part_i < 3; part_i++){
      h_EffEnergy[plane_i][part_i]->BayesDivide(h_EffEnergy_pass[plane_i][part_i], h_EffEnergy_tot[plane_i][part_i]);
      efficiency[plane_i][part_i] /= total[plane_i][part_i];
      std::cout<<"Plane["<<plane_i<<"] Particle["<<part_i<<"]: Efficiency = "<<efficiency[plane_i][part_i]<<" ("<<total[plane_i][part_i]<<" total tracks)"<<std::endl;
      std::cout<<"Number of tracks cut = "<<nCut[plane_i][part_i]<<endl;

      // Add label with total efficiencies to efficiency plots
      TString label = Form("Total = %.3f",efficiency[plane_i][part_i]);
      TLatex *latex = new TLatex(h_EffEnergy[plane_i][part_i]->GetX()[0], h_EffEnergy[plane_i][part_i]->GetY()[0], label);
      h_EffEnergy[plane_i][part_i]->GetListOfFunctions()->Add(latex);
      h_EffEnergy[plane_i][part_i]->GetYaxis()->SetRangeUser(0,1);
      h_EffEnergy[plane_i][part_i]->GetYaxis()->SetTitleOffset(0.65);
      h_EffEnergy[plane_i][part_i]->Draw("ap");
    }
  }

  //Write all histograms and graphs to file
  for (unsigned int i = 0; i < v_AllTH2.size(); i++){
    v_AllTH2[i]->Write();
  }
  for (unsigned int i = 0; i < v_AllTH1.size(); i++){
    v_AllTH1[i]->Write();
  }
  for (unsigned int i = 0; i < v_AllTGraph.size(); i++){
    v_AllTGraph[i]->Write();
  }

}
