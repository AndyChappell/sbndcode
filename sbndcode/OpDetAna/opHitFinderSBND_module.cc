////////////////////////////////////////////////////////////////////////
// Class:       opHitFinderSBND
// Module Type: producer
// File:        opHitFinderSBND_module.cc
//
// This module produces an OpHit object for light analysis
// Created by L. Paulucci and F. Marinho
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Utilities/Exception.h"
#include "canvas/Utilities/InputTag.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include "larcore/Geometry/Geometry.h"
#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
//#include "larana/OpticalDetector/OpHitFinder/OpHitAlg.h"
//#include "lardataobj/Simulation/BeamGateInfo.h"

#include "lardata/DetectorInfoServices/DetectorClocksServiceStandard.h"
#include "lardataobj/Simulation/sim.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/SimPhotons.h"
#include "sbndcode/Utilities/SignalShapingServiceSBND.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
//#include "larsim/MCCheater/PhotonBackTracker.h"

#include <memory>
#include "TMath.h"
#include "TH1D.h"
#include "TRandom3.h"
#include "TF1.h"

namespace opdet{

  class opHitFinderSBND;

  class opHitFinderSBND : public art::EDProducer {
  public:
    explicit opHitFinderSBND(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
    opHitFinderSBND(opHitFinderSBND const &) = delete;
    opHitFinderSBND(opHitFinderSBND &&) = delete;
    opHitFinderSBND & operator = (opHitFinderSBND const &) = delete;
    opHitFinderSBND & operator = (opHitFinderSBND &&) = delete;

  // Required functions.
    void produce(art::Event & e) override;

  private:

  // Declare member data here.
    std::string fInputModuleName;
  //  art::ServiceHandle<cheat::PhotonBackTracker> pbt;
    double fSampling; //in GHz
    double fTransitTime; //ns
    double fRiseTime; //in ns
    double fMeanAmplitude; //in ADC
    double fReadoutWindow; //in ns
    double fPreTrigger; //in ns
    double fSaturation; //in number of p.e.
    double fArea1pe; //area of 1 pe in ADC*ns
    int fThreshold; //in ADC
    int fEvNumber;
    int fChNumber;
    int fSize;
    int fTimePMT;         //Start time of PMT signal
    int fTimeMax;         //Time of maximum (minimum) PMT signal
    int fRecoTime;         //Diff for reconstructed time of PMT signal
    TH1D* wvfHist;          //processed waveform histogram 
    void subtractBaseline(TH1D* hist);
    bool findPeak(TH1D* h, size_t& time, double& Area);
    std::stringstream histname;
  };

  opHitFinderSBND::opHitFinderSBND(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
  {
    fInputModuleName = p.get< std::string >("InputModule" );
    fTransitTime     = p.get< double >("TransitTime"  ); //ns
    fRiseTime        = p.get< double >("RiseTime"     ); //in ns
    fMeanAmplitude   = p.get< double >("MeanAmplitude"); //in ADC
    fReadoutWindow   = p.get< double >("ReadoutWindow"); //in ns
    fPreTrigger      = p.get< double >("PreTrigger"   ); //in ns
    fSaturation      = p.get< double >("Saturation"   ); //in number of p.e.
    fArea1pe         = p.get< double >("Area1pe"      ); //in ADC*ns
    fSampling        = p.get< double >("Sampling"     ); //in GHz
    fThreshold       = p.get< double >("Threshold"    ); //in ADC

  // Call appropriate produces<>() functions here.
    produces<std::vector<recob::OpHit>>();
  }

  void opHitFinderSBND::produce(art::Event & e)
  {
  // Implementation of required member function here.
    fEvNumber = e.id().event();
    std::cout << "Event #" << fEvNumber << std::endl;

    std::unique_ptr< std::vector< recob::OpHit > > pulseVecPtr(std::make_unique< std::vector< recob::OpHit > > ());  

    art::ServiceHandle<art::TFileService> tfs;
    histname.str(std::string());
    histname << "event_" << fEvNumber;
    TH1D* htime = tfs->make< TH1D >(histname.str().c_str(), "", 200,-100.0,100.0);
    art::Handle< std::vector< raw::OpDetWaveform > > wvfHandle;
    e.getByLabel(fInputModuleName, wvfHandle);

    if(!wvfHandle.isValid()){
  	std::cout <<Form("Did not find any waveform") << std::endl;
    }

    std::cout << "Number of photon channels: " << wvfHandle->size() << std::endl;

    size_t time;
    size_t tmin = 1e9;
    double int_total, time_abs=0, FWHM=1, Area=1, min=0, phelec, fasttotal;
    unsigned short frame=1;

    for(auto const& wvf : (*wvfHandle)){
	fChNumber = wvf.ChannelNumber();
	std::cout << "Photon channel: " << fChNumber << std::endl;
	histname.str(std::string());
        histname << "event_" << fEvNumber <<"_opchannel_" << fChNumber;
	wvfHist = new TH1D(histname.str().c_str(), "Histogram", wvf.size(),0, double(wvf.size()));
	for(unsigned int i=0;i<wvf.size();i++){
	  wvfHist->SetBinContent(i,wvf[i]);
	}
	//Findind the signal starting time for each channel
	subtractBaseline(wvfHist);
        int_total= wvfHist->Integral(0, wvf.size());
	tmin = 1e9;
        while(findPeak(wvfHist,time,Area)){
          time = time/fSampling;
          std::cout << " Find peak time: " << time << std::endl;
          if(time<tmin)tmin=time;
	  fRecoTime = tmin - (fPreTrigger - wvf.TimeStamp());
          fasttotal=Area/int_total;
          phelec=Area/fArea1pe;
          htime->Fill(fRecoTime);
	  std::cout << "TimeStamp " << wvf.TimeStamp() << " Rec time: " << tmin << " Diff " << fRecoTime << " wvf size: "<< wvf.size() <<std::endl;
       
	  recob::OpHit opHit(fChNumber, tmin, time_abs, frame, FWHM, Area, min, phelec, fasttotal);//including hit info
          pulseVecPtr->emplace_back(opHit);
        }

	delete wvfHist;
    }
    e.put(std::move(pulseVecPtr));
  }

  DEFINE_ART_MODULE(opHitFinderSBND)

  void opHitFinderSBND::subtractBaseline(TH1D* h){
    double baseline = 0.0;
    int width = 100;
  
    for(int i=1; i<=width; i++){
	baseline+=h->GetBinContent(i);
    }
    baseline=baseline/width;

    for(int i=1; i<h->GetNbinsX(); i++)h->SetBinContent(i, baseline-(h->GetBinContent(i)));

  }

  bool opHitFinderSBND::findPeak(TH1D* h, size_t& time, double& Area){

    //Gets info from highest peak and suppress it in histogram
    double aux = h->GetMaximum();
    double time_end, max = aux;
    size_t bin = h->GetMaximumBin();
//    size_t bmax = bin;

    //std::cout << "aux: " << aux << " Threshold: " << fThreshold << std::endl;

 //   time = bin; //for peak time
 
    if(aux<fThreshold)return false;

    while(aux>fThreshold){
        bin++;	
        aux = h->GetBinContent(bin);
    }
    time_end=bin; //looking for the length of the peak

    aux=max;
    while(aux>fThreshold){
        bin--;
        aux = h->GetBinContent(bin);
    }
    time = bin; //for rise time

    Area=h->Integral(time,time_end);

    bin = time;
    aux = h->GetBinContent(time);
   
   while(aux>fThreshold){
        h->SetBinContent(bin,0.0);
        bin++;
        aux = h->GetBinContent(bin);
    }
    return true;		
  }

}
